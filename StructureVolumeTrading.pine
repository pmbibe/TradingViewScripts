// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// Structure & Volume Trading System v2.0 - OPTIMIZED
// Professional trading system with reduced noise and improved accuracy
// Author: Claude AI Assistant
// Version: 2.0 - Performance & UI Optimized

//@version=5
indicator("Structure & Volume Trading System v2.0", "SVT v2", overlay=true, max_labels_count=100, max_lines_count=50, max_boxes_count=10)

// ============================================
// SECTION 1: CONSTANTS & COLOR SCHEME
// ============================================

COLOR_BULLISH = color.new(#26a69a, 0)
COLOR_BEARISH = color.new(#ef5350, 0)
COLOR_NEUTRAL = color.new(#78909c, 0)
COLOR_WARNING = color.new(#ffa726, 0)
COLOR_INFO = color.new(#42a5f5, 0)

// ============================================
// SECTION 2: INPUT SETTINGS & AUTO TIMEFRAME
// ============================================

// --- Accumulation Settings ---
string GROUP_ACCUMULATION = "ðŸ“Š Accumulation Settings"
useAutoTF = input.bool(true, "Auto Timeframe Adjustment", group=GROUP_ACCUMULATION, tooltip="Automatically adjust parameters based on chart timeframe")
accumPeriod_input = input.int(12, "Accumulation Period (Bars)", minval=4, maxval=100, group=GROUP_ACCUMULATION, tooltip="Detection lookback for box size")
maxRangePercent_input = input.float(12.0, "Max Range %", minval=5.0, maxval=30.0, step=0.5, group=GROUP_ACCUMULATION, tooltip="Dynamic threshold based on volatility")
requireVolDecrease = input.bool(true, "Require Volume Decrease", group=GROUP_ACCUMULATION)
minAccumBars_input = input.int(18, "Min Accumulation Bars", minval=10, maxval=50, group=GROUP_ACCUMULATION, tooltip="Minimum bars to qualify as valid accumulation")

// === AUTO-DETECT TIMEFRAME & ADJUST PARAMETERS ===
int tfMinutes = timeframe.in_seconds() / 60

// Calculate auto-adjusted values based on timeframe
int auto_accumPeriod = tfMinutes <= 1 ? 20 : tfMinutes <= 3 ? 18 : tfMinutes <= 5 ? 15 : tfMinutes <= 15 ? 12 : tfMinutes <= 30 ? 10 : tfMinutes <= 60 ? 8 : 6
float auto_maxRange = tfMinutes <= 1 ? 8.0 : tfMinutes <= 3 ? 9.0 : tfMinutes <= 5 ? 10.0 : tfMinutes <= 15 ? 12.0 : tfMinutes <= 30 ? 14.0 : tfMinutes <= 60 ? 15.0 : 18.0
int auto_minBars = tfMinutes <= 1 ? 25 : tfMinutes <= 3 ? 22 : tfMinutes <= 5 ? 20 : tfMinutes <= 15 ? 18 : tfMinutes <= 30 ? 15 : tfMinutes <= 60 ? 12 : 10

// Use auto values if enabled, otherwise use user inputs
accumPeriod = useAutoTF ? auto_accumPeriod : accumPeriod_input
maxRangePercent = useAutoTF ? auto_maxRange : maxRangePercent_input
minAccumBars = useAutoTF ? auto_minBars : minAccumBars_input

// --- Volume Settings ---
string GROUP_VOLUME = "ðŸ“ˆ Volume Settings"
volMAPeriod = input.int(20, "Volume MA Period", minval=5, maxval=100, group=GROUP_VOLUME)
spikeMultiplier = input.float(3.0, "Volume Spike Multiplier", minval=2.0, maxval=5.0, step=0.1, group=GROUP_VOLUME, tooltip="Increased threshold for better quality")
showVolumeHighlights = input.bool(true, "Show Volume Highlights", group=GROUP_VOLUME)

// --- Signal Settings ---
string GROUP_SIGNALS = "ðŸŽ¯ Signal Settings"
showLongSignals = input.bool(true, "Show Long Signals", group=GROUP_SIGNALS)
showShortSignals = input.bool(true, "Show Short Signals", group=GROUP_SIGNALS)
requireConfirmation = input.bool(true, "Require Breakout Confirmation", group=GROUP_SIGNALS, tooltip="Wait for confirmation bar before signal")
showDivergence = input.bool(true, "Show Volume Divergence", group=GROUP_SIGNALS)

// --- Risk Management ---
string GROUP_RISK = "ðŸ’° Risk Management"
showLevels = input.bool(true, "Show Entry/SL/TP Lines", group=GROUP_RISK)
rrMultiplier1 = input.float(2.0, "RR Ratio for TP1", minval=1.0, maxval=5.0, step=0.5, group=GROUP_RISK)
rrMultiplier2 = input.float(3.0, "RR Ratio for TP2", minval=2.0, maxval=8.0, step=0.5, group=GROUP_RISK)
rrMultiplier3 = input.float(4.0, "RR Ratio for TP3", minval=3.0, maxval=10.0, step=0.5, group=GROUP_RISK)
maxRiskPercent = input.float(15.0, "Max Risk %", minval=5.0, maxval=30.0, step=1.0, group=GROUP_RISK)

// --- Divergence Settings ---
string GROUP_DIVERGENCE = "âš ï¸ Divergence Settings"
pivotLookback = input.int(5, "Pivot Lookback", minval=2, maxval=20, group=GROUP_DIVERGENCE)
minDivergencePercent = input.float(30.0, "Min Volume Decrease %", minval=10.0, maxval=50.0, step=5.0, group=GROUP_DIVERGENCE, tooltip="Stricter threshold for quality")
minPivotDistance = input.int(20, "Min Pivot Distance (Bars)", minval=10, maxval=50, group=GROUP_DIVERGENCE)

// --- Visual Settings ---
string GROUP_VISUAL = "ðŸŽ¨ Visual Settings"
showInfoPanel = input.bool(true, "Show Info Panel", group=GROUP_VISUAL)
showEMAs = input.bool(true, "Show EMAs", group=GROUP_VISUAL)
labelSize = input.string("normal", "Label Size", options=["small", "normal", "large"], group=GROUP_VISUAL)
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group=GROUP_VISUAL)

// ============================================
// SECTION 3: VARIABLES & ARRAYS
// ============================================

// --- Basic Calculations ---
volumeMA = ta.sma(volume, volMAPeriod)
volumeRatio = volumeMA > 0 ? volume / volumeMA : 0.0
isBullishBar = close > open
isBearishBar = close < open
bodySize = math.abs(close - open)
candleRange = high - low
bodyPercent = candleRange > 0 ? (bodySize / candleRange) * 100 : 0

// --- EMAs ---
ema20 = ta.ema(close, 20)
ema50 = ta.ema(close, 50)

// --- ATR ---
atrValue = ta.atr(14)

// --- Volume Conditions ---
isVolumeSpike = volumeRatio >= spikeMultiplier
isStrongSpike = volumeRatio >= (spikeMultiplier * 1.5)

// --- Accumulation State (ADVANCED v3.0) ---
var box currentAccumBox = na
var label accumLabel = na
var bool isDrawingAccum = false
var float lastAccumHigh = na
var float lastAccumLow = na
var int accumBarsCount = 0
var int accumStartBar = 0

// State machine variables
var string accumState = "IDLE"  // States: IDLE, DETECTING, CONFIRMED, CLOSING, CLOSED
var int stateBarCount = 0
var float frozenTop = na
var float frozenBottom = na
var int violationCount = 0

// Overlap prevention tracking
var array<int> archivedStarts = array.new_int(0)
var array<int> archivedEnds = array.new_int(0)
var int lastBoxEndBar = 0

// --- Trade State (OPTIMIZED) ---
var line entryLine = na
var line stopLine = na
var line tp1Line = na
var line tp2Line = na
var line tp3Line = na
var label entryLabel = na
var label stopLabel = na
var label tp1Label = na

var float entryPrice = na
var float stopLoss = na
var float takeProfit1 = na
var float takeProfit2 = na
var float takeProfit3 = na
var bool hasActiveTrade = false
var string tradeDirection = ""
var int barsInTrade = 0

// --- Breakout Confirmation State ---
var bool waitingConfirmation = false
var float breakoutLevel = na
var string breakoutType = ""

// --- Signal Labels Tracking ---
var array<label> signalLabels = array.new_label(0)
var int lastVolLabelBar = 0

// --- Divergence Lines Tracking ---
var array<line> divergenceLines = array.new_line(0)
var array<label> divergenceLabels = array.new_label(0)

// --- Pivot Storage ---
var array<float> pivotHighPrices = array.new_float(0)
var array<int> pivotHighBars = array.new_int(0)
var array<float> pivotHighVolumes = array.new_float(0)
var array<float> pivotLowPrices = array.new_float(0)
var array<int> pivotLowBars = array.new_int(0)
var array<float> pivotLowVolumes = array.new_float(0)

// ============================================
// SECTION 4: HELPER FUNCTIONS
// ============================================

// Delete line safely (no return value needed)
deleteLine(line l) =>
    if not na(l)
        line.delete(l)

// Delete label safely (no return value needed)
deleteLabel(label lbl) =>
    if not na(lbl)
        label.delete(lbl)

// Cleanup old divergence objects
cleanupDivergence() =>
    maxDivLines = 3
    while array.size(divergenceLines) > maxDivLines
        oldLine = array.shift(divergenceLines)
        line.delete(oldLine)

    while array.size(divergenceLabels) > maxDivLines
        oldLabel = array.shift(divergenceLabels)
        label.delete(oldLabel)

// Cleanup old signal labels
cleanupSignalLabels() =>
    maxLabels = 10
    while array.size(signalLabels) > maxLabels
        oldLabel = array.shift(signalLabels)
        label.delete(oldLabel)

// ============================================
// SECTION 5: ACCUMULATION DETECTION (ADVANCED v3.0)
// ============================================
// Algorithm: Multi-condition scoring + State machine + Dynamic thresholds
// Features: Overlap prevention, Size freeze, Conditional tolerance

// === CONSTANTS ===
LOOKBACK_DETECTION = accumPeriod  // Short lookback for box
LOOKBACK_CONTEXT = 50  // Long lookback for market context
MIN_DETECTING_BARS = 3  // Bars needed to start detection
MIN_CONFIRMED_BARS = 5  // Additional bars to confirm
MIN_BOX_DISTANCE = tfMinutes <= 5 ? 20 : tfMinutes <= 15 ? 15 : tfMinutes <= 60 ? 10 : 8

// === STEP 1: CALCULATE METRICS ===

// 1.1 Price Range (SHORT lookback for box)
highestHigh = ta.highest(high, LOOKBACK_DETECTION)
lowestLow = ta.lowest(low, LOOKBACK_DETECTION)
priceRangePercent = lowestLow > 0 ? ((highestHigh - lowestLow) / lowestLow) * 100 : 100.0

// 1.2 Market Volatility (for dynamic threshold)
atr14 = ta.atr(14)
avgVolatility = close > 0 ? (atr14 / close) * 100 : 0.0
smoothedVolatility = ta.sma(avgVolatility, 20)

// 1.3 Dynamic Threshold
float effectiveThreshold = smoothedVolatility < 2.0 ? maxRangePercent * 0.5 : smoothedVolatility < 4.0 ? maxRangePercent * 0.75 : maxRangePercent

// 1.4 Volume Metrics
volumeRank = ta.percentrank(volume, 50)
volumeMA20 = ta.sma(volume, 20)
volumeMA20_old = volumeMA20[5]
volumeSlope = volumeMA20_old > 0 ? ((volumeMA20 - volumeMA20_old) / volumeMA20_old) * 100 : 0.0
maxVolumeLast10 = ta.highest(volume, 10)

// 1.5 Volume Regime
string volumeRegime = volumeRank < 30 ? "LOW" : volumeRank < 70 ? "NORMAL" : "HIGH"

isVolumeDeclining = volumeSlope < -5.0
hasRecentSpike = maxVolumeLast10 > (volumeMA * 2.0)

// 1.6 EMA Slope (sideways check)
ema20Slope = ema20[5] > 0 ? (ema20 - ema20[5]) / ema20[5] * 100 : 0.0

// === STEP 2: SCORING SYSTEM (0-10 points) ===
int accumScore = 0

// Score 1: Range compression (0-3 points)
if priceRangePercent <= effectiveThreshold * 0.5
    accumScore += 3
else if priceRangePercent <= effectiveThreshold * 0.75
    accumScore += 2
else if priceRangePercent <= effectiveThreshold
    accumScore += 1

// Score 2: Volume regime (0-3 points)
if volumeRegime == "LOW"
    accumScore += 2
if isVolumeDeclining
    accumScore += 1

// Score 3: No spikes (0-2 points)
if not hasRecentSpike
    accumScore += 2

// Score 4: Sideways movement (0-2 points)
if math.abs(ema20Slope) < 0.5
    accumScore += 2
else if math.abs(ema20Slope) < 1.0
    accumScore += 1

// Final qualification
bool isQualified = accumScore >= 7

// === STEP 3: CALCULATE STRENGTH (for conditional tolerance) ===
int accumStrength = 0

// Strength from duration
if stateBarCount >= 30
    accumStrength += 4
else if stateBarCount >= 20
    accumStrength += 3
else if stateBarCount >= 10
    accumStrength += 2

// Strength from score quality
if accumScore >= 9
    accumStrength += 3
else if accumScore >= 8
    accumStrength += 2
else if accumScore >= 7
    accumStrength += 1

// Strength from volume quality
if volumeRank < 20
    accumStrength += 3
else if volumeRank < 30
    accumStrength += 2

// Determine allowed violations (conditional tolerance)
int allowedViolations = accumStrength >= 8 ? 5 : accumStrength >= 6 ? 3 : accumStrength >= 4 ? 2 : 1

// === STEP 4: CHECK OVERLAP PREVENTION ===
bool canCreateNewBox = true
if array.size(archivedEnds) > 0
    lastEnd = array.get(archivedEnds, array.size(archivedEnds) - 1)
    if (bar_index - lastEnd) < MIN_BOX_DISTANCE
        canCreateNewBox := false

// === STEP 5: STATE MACHINE ===

if accumState == "IDLE"
    // Reset counters in IDLE
    if isQualified
        stateBarCount += 1
        if stateBarCount >= MIN_DETECTING_BARS and canCreateNewBox
            // Transition to DETECTING
            accumState := "DETECTING"
            accumStartBar := bar_index - LOOKBACK_DETECTION + 1
            stateBarCount := 0
    else
        stateBarCount := 0

else if accumState == "DETECTING"
    if isQualified
        stateBarCount += 1
        if stateBarCount >= MIN_CONFIRMED_BARS
            // Transition to CONFIRMED
            accumState := "CONFIRMED"
            stateBarCount := 0
            violationCount := 0

            // FREEZE dimensions (critical - no updates after this)
            frozenTop := highestHigh
            frozenBottom := lowestLow

            // CREATE BOX with frozen size
            currentAccumBox := box.new(accumStartBar, frozenTop, bar_index, frozenBottom, border_color=COLOR_INFO, bgcolor=color.new(COLOR_INFO, 92), border_width=1)

            // Create label
            accumLabel := label.new(bar_index, frozenTop, "ACCUMULATION", color=color.new(COLOR_INFO, 70), textcolor=color.white, style=label.style_label_down, size=size.small)

            isDrawingAccum := true
    else
        // Failed detection - back to IDLE
        accumState := "IDLE"
        stateBarCount := 0

else if accumState == "CONFIRMED"
    stateBarCount += 1

    if isQualified
        // Reset violations when condition is met
        violationCount := 0

        // Update ONLY right edge (NO top/bottom updates - FROZEN SIZE)
        if not na(currentAccumBox)
            box.set_right(currentAccumBox, bar_index)
        if not na(accumLabel)
            label.set_x(accumLabel, bar_index)
    else
        // Violation detected
        violationCount += 1

        if violationCount > allowedViolations
            // Close accumulation
            if stateBarCount >= minAccumBars
                // Valid accumulation - proceed to CLOSING
                accumState := "CLOSING"
            else
                // Too short - delete box and return to IDLE
                if not na(currentAccumBox)
                    box.delete(currentAccumBox)
                if not na(accumLabel)
                    label.delete(accumLabel)
                accumState := "IDLE"
                isDrawingAccum := false
                stateBarCount := 0
        else
            // Within tolerance - continue extending
            if not na(currentAccumBox)
                box.set_right(currentAccumBox, bar_index)
            if not na(accumLabel)
                label.set_x(accumLabel, bar_index)

else if accumState == "CLOSING"
    // Archive the box position
    array.push(archivedStarts, accumStartBar)
    array.push(archivedEnds, bar_index)
    lastBoxEndBar := bar_index

    // Limit array size
    if array.size(archivedStarts) > 5
        array.shift(archivedStarts)
        array.shift(archivedEnds)

    // Store last box levels for breakout detection
    lastAccumHigh := frozenTop
    lastAccumLow := frozenBottom
    accumBarsCount := stateBarCount

    // Transition to CLOSED
    accumState := "CLOSED"
    isDrawingAccum := false
    stateBarCount := 0

else if accumState == "CLOSED"
    // Cooldown period
    if (bar_index - lastBoxEndBar) >= MIN_BOX_DISTANCE
        accumState := "IDLE"
        stateBarCount := 0
// ============================================
// SECTION 6: VOLUME ANALYSIS (OPTIMIZED)
// ============================================

// Background highlight for extreme volume spikes (subtle)
bgcolor(showVolumeHighlights and isStrongSpike ? color.new(COLOR_WARNING, 96) : na)

// Volume spike labels - ONLY at key moments
minBarsBetweenLabels = 10
canShowVolLabel = (bar_index - lastVolLabelBar) >= minBarsBetweenLabels

if showVolumeHighlights and isStrongSpike and canShowVolLabel and barstate.isconfirmed
    volText = str.tostring(math.round(volumeRatio, 1)) + "x"
    label.new(bar_index, high, volText, yloc=yloc.abovebar, color=color.new(COLOR_WARNING, 85), textcolor=color.white, style=label.style_label_down, size=size.tiny)
    lastVolLabelBar := bar_index

// ============================================
// SECTION 7: DIVERGENCE DETECTION (STRICT FILTERS)
// ============================================

// Detect pivots
pivotHigh = ta.pivothigh(high, pivotLookback, pivotLookback)
pivotLow = ta.pivotlow(low, pivotLookback, pivotLookback)

// Store pivot highs
if not na(pivotHigh)
    if array.size(pivotHighPrices) >= 10
        array.shift(pivotHighPrices)
        array.shift(pivotHighBars)
        array.shift(pivotHighVolumes)

    array.push(pivotHighPrices, pivotHigh)
    array.push(pivotHighBars, bar_index - pivotLookback)

    pivotVol = ta.sma(volume, 3)[pivotLookback]
    array.push(pivotHighVolumes, pivotVol)

// Store pivot lows
if not na(pivotLow)
    if array.size(pivotLowPrices) >= 10
        array.shift(pivotLowPrices)
        array.shift(pivotLowBars)
        array.shift(pivotLowVolumes)

    array.push(pivotLowPrices, pivotLow)
    array.push(pivotLowBars, bar_index - pivotLookback)

    pivotVol = ta.sma(volume, 3)[pivotLookback]
    array.push(pivotLowVolumes, pivotVol)

// Detect Bearish Divergence (STRICT)
bearishDivergence = false
if showDivergence and array.size(pivotHighPrices) >= 2
    lastPrice = array.get(pivotHighPrices, array.size(pivotHighPrices) - 1)
    prevPrice = array.get(pivotHighPrices, array.size(pivotHighPrices) - 2)
    lastVol = array.get(pivotHighVolumes, array.size(pivotHighVolumes) - 1)
    prevVol = array.get(pivotHighVolumes, array.size(pivotHighVolumes) - 2)
    lastBar = array.get(pivotHighBars, array.size(pivotHighBars) - 1)
    prevBar = array.get(pivotHighBars, array.size(pivotHighBars) - 2)

    // STRICT CONDITIONS
    priceHigher = lastPrice > (prevPrice * 1.02)  // Price 2% higher
    volumeLower = prevVol > 0 ? ((prevVol - lastVol) / prevVol * 100) >= minDivergencePercent : false
    validDistance = (lastBar - prevBar) >= minPivotDistance
    isNearHigh = lastPrice >= ta.highest(high, 50) * 0.95  // Near 50-bar high

    bearishDivergence := priceHigher and volumeLower and validDistance and isNearHigh

    // Draw divergence line (LIMITED)
    if bearishDivergence and not na(pivotHigh)
        newLine = line.new(prevBar, prevPrice, lastBar, lastPrice, color=COLOR_BEARISH, style=line.style_dashed, width=2)
        array.push(divergenceLines, newLine)

        newLabel = label.new(lastBar, lastPrice, "BEAR DIV", yloc=yloc.abovebar, color=COLOR_BEARISH, textcolor=color.white, style=label.style_label_down, size=size.small)
        array.push(divergenceLabels, newLabel)

        cleanupDivergence()

// Detect Bullish Divergence (STRICT)
bullishDivergence = false
if showDivergence and array.size(pivotLowPrices) >= 2
    lastPrice = array.get(pivotLowPrices, array.size(pivotLowPrices) - 1)
    prevPrice = array.get(pivotLowPrices, array.size(pivotLowPrices) - 2)
    lastVol = array.get(pivotLowVolumes, array.size(pivotLowVolumes) - 1)
    prevVol = array.get(pivotLowVolumes, array.size(pivotLowVolumes) - 2)
    lastBar = array.get(pivotLowBars, array.size(pivotLowBars) - 1)
    prevBar = array.get(pivotLowBars, array.size(pivotLowBars) - 2)

    // STRICT CONDITIONS
    priceLower = lastPrice < (prevPrice * 0.98)  // Price 2% lower
    volumeLower = prevVol > 0 ? ((prevVol - lastVol) / prevVol * 100) >= minDivergencePercent : false
    validDistance = (lastBar - prevBar) >= minPivotDistance
    isNearLow = lastPrice <= ta.lowest(low, 50) * 1.05  // Near 50-bar low

    bullishDivergence := priceLower and volumeLower and validDistance and isNearLow

    if bullishDivergence and not na(pivotLow)
        newLine = line.new(prevBar, prevPrice, lastBar, lastPrice, color=COLOR_BULLISH, style=line.style_dashed, width=2)
        array.push(divergenceLines, newLine)

        newLabel = label.new(lastBar, lastPrice, "BULL DIV", yloc=yloc.belowbar, color=COLOR_BULLISH, textcolor=color.white, style=label.style_label_up, size=size.small)
        array.push(divergenceLabels, newLabel)

        cleanupDivergence()

// ============================================
// SECTION 8: BREAKOUT DETECTION (WITH CONFIRMATION)
// ============================================

// Potential breakout detection
potentialBullishBreakout = false
potentialBearishBreakout = false

// Final breakout variables (will be set by confirmation logic)
bullishBreakout = false
bearishBreakout = false

if not na(lastAccumHigh) and accumBarsCount == 0 and accumBarsCount[1] >= minAccumBars
    // Bullish breakout
    if close > lastAccumHigh[1] and isVolumeSpike and isBullishBar and bodyPercent >= 60
        potentialBullishBreakout := true

    // Bearish breakout
    if close < lastAccumLow[1] and isVolumeSpike and isBearishBar and bodyPercent >= 60
        potentialBearishBreakout := true

// Confirmation logic
if requireConfirmation
    // Start confirmation process
    if potentialBullishBreakout and not waitingConfirmation
        waitingConfirmation := true
        breakoutLevel := lastAccumHigh[1]
        breakoutType := "LONG"

    if potentialBearishBreakout and not waitingConfirmation
        waitingConfirmation := true
        breakoutLevel := lastAccumLow[1]
        breakoutType := "SHORT"

    // Check confirmation
    confirmedBullish = false
    confirmedBearish = false

    if waitingConfirmation and breakoutType == "LONG"
        if close > breakoutLevel and low > breakoutLevel * 0.98 and volume > volumeMA * 1.5
            confirmedBullish := true
            waitingConfirmation := false
        else if close < breakoutLevel * 0.97
            waitingConfirmation := false

    if waitingConfirmation and breakoutType == "SHORT"
        if close < breakoutLevel and high < breakoutLevel * 1.02 and volume > volumeMA * 1.5
            confirmedBearish := true
            waitingConfirmation := false
        else if close > breakoutLevel * 1.03
            waitingConfirmation := false

    bullishBreakout = confirmedBullish
    bearishBreakout = confirmedBearish
else
    // No confirmation required
    bullishBreakout = potentialBullishBreakout
    bearishBreakout = potentialBearishBreakout

// ============================================
// SECTION 9: ENTRY/SL/TP MANAGEMENT (OPTIMIZED)
// ============================================

// Long Signal
longSignal = bullishBreakout and showLongSignals and barstate.isconfirmed

if longSignal and not hasActiveTrade
    entryPrice := close
    stopLoss := not na(lastAccumLow) ? lastAccumLow : close - (atrValue * 1.5)

    riskAmount = entryPrice - stopLoss
    riskPercent = entryPrice > 0 ? (riskAmount / entryPrice) * 100 : 100.0

    // Validate risk
    if riskPercent <= maxRiskPercent and riskPercent > 0
        takeProfit1 := entryPrice + (riskAmount * rrMultiplier1)
        takeProfit2 := entryPrice + (riskAmount * rrMultiplier2)
        takeProfit3 := entryPrice + (riskAmount * rrMultiplier3)

        hasActiveTrade := true
        tradeDirection := "LONG"
        barsInTrade := 0

        // Delete old lines
        deleteLine(entryLine)
        deleteLine(stopLine)
        deleteLine(tp1Line)
        deleteLine(tp2Line)
        deleteLine(tp3Line)
        deleteLabel(entryLabel)
        deleteLabel(stopLabel)
        deleteLabel(tp1Label)

        // Create new lines (ONCE)
        if showLevels
            entryLine := line.new(bar_index, entryPrice, bar_index + 50, entryPrice, color=COLOR_INFO, style=line.style_solid, width=lineWidth)
            stopLine := line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=COLOR_BEARISH, style=line.style_dashed, width=lineWidth)
            tp1Line := line.new(bar_index, takeProfit1, bar_index + 50, takeProfit1, color=color.new(COLOR_BULLISH, 30), style=line.style_dashed, width=1)
            tp2Line := line.new(bar_index, takeProfit2, bar_index + 50, takeProfit2, color=color.new(COLOR_BULLISH, 30), style=line.style_dashed, width=1)
            tp3Line := line.new(bar_index, takeProfit3, bar_index + 50, takeProfit3, color=color.new(COLOR_BULLISH, 30), style=line.style_dotted, width=1)

            entryLabel := label.new(bar_index, entryPrice, "ENTRY", color=COLOR_INFO, textcolor=color.white, style=label.style_label_left, size=size.tiny)
            stopLabel := label.new(bar_index, stopLoss, "SL -" + str.tostring(riskPercent, "#.#") + "%", color=COLOR_BEARISH, textcolor=color.white, style=label.style_label_left, size=size.tiny)
            tp1Label := label.new(bar_index, takeProfit1, "TP1", color=COLOR_BULLISH, textcolor=color.white, style=label.style_label_left, size=size.tiny)

// Short Signal
shortSignal = bearishBreakout and showShortSignals and barstate.isconfirmed

if shortSignal and not hasActiveTrade
    entryPrice := close
    stopLoss := not na(lastAccumHigh) ? lastAccumHigh : close + (atrValue * 1.5)

    riskAmount = stopLoss - entryPrice
    riskPercent = entryPrice > 0 ? (riskAmount / entryPrice) * 100 : 100.0

    if riskPercent <= maxRiskPercent and riskPercent > 0
        takeProfit1 := entryPrice - (riskAmount * rrMultiplier1)
        takeProfit2 := entryPrice - (riskAmount * rrMultiplier2)
        takeProfit3 := entryPrice - (riskAmount * rrMultiplier3)

        hasActiveTrade := true
        tradeDirection := "SHORT"
        barsInTrade := 0

        // Delete old lines
        deleteLine(entryLine)
        deleteLine(stopLine)
        deleteLine(tp1Line)
        deleteLine(tp2Line)
        deleteLine(tp3Line)
        deleteLabel(entryLabel)
        deleteLabel(stopLabel)
        deleteLabel(tp1Label)

        // Create new lines
        if showLevels
            entryLine := line.new(bar_index, entryPrice, bar_index + 50, entryPrice, color=COLOR_INFO, style=line.style_solid, width=lineWidth)
            stopLine := line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=COLOR_BEARISH, style=line.style_dashed, width=lineWidth)
            tp1Line := line.new(bar_index, takeProfit1, bar_index + 50, takeProfit1, color=color.new(COLOR_BULLISH, 30), style=line.style_dashed, width=1)
            tp2Line := line.new(bar_index, takeProfit2, bar_index + 50, takeProfit2, color=color.new(COLOR_BULLISH, 30), style=line.style_dashed, width=1)
            tp3Line := line.new(bar_index, takeProfit3, bar_index + 50, takeProfit3, color=color.new(COLOR_BULLISH, 30), style=line.style_dotted, width=1)

            entryLabel := label.new(bar_index, entryPrice, "ENTRY", color=COLOR_INFO, textcolor=color.white, style=label.style_label_left, size=size.tiny)
            stopLabel := label.new(bar_index, stopLoss, "SL -" + str.tostring(riskPercent, "#.#") + "%", color=COLOR_BEARISH, textcolor=color.white, style=label.style_label_left, size=size.tiny)
            tp1Label := label.new(bar_index, takeProfit1, "TP1", color=COLOR_BULLISH, textcolor=color.white, style=label.style_label_left, size=size.tiny)

// Update active trade
if hasActiveTrade
    barsInTrade += 1

    // Update line positions
    if showLevels and not na(entryLine)
        line.set_x1(entryLine, bar_index - barsInTrade)
        line.set_x2(entryLine, bar_index + 20)
        line.set_x1(stopLine, bar_index - barsInTrade)
        line.set_x2(stopLine, bar_index + 20)
        line.set_x1(tp1Line, bar_index - barsInTrade)
        line.set_x2(tp1Line, bar_index + 20)
        line.set_x1(tp2Line, bar_index - barsInTrade)
        line.set_x2(tp2Line, bar_index + 20)
        line.set_x1(tp3Line, bar_index - barsInTrade)
        line.set_x2(tp3Line, bar_index + 20)

        label.set_x(entryLabel, bar_index)
        label.set_x(stopLabel, bar_index)
        label.set_x(tp1Label, bar_index)

    // Check exit conditions
    exitTrade = false
    if tradeDirection == "LONG"
        if close <= stopLoss or close >= takeProfit1
            exitTrade := true
    else if tradeDirection == "SHORT"
        if close >= stopLoss or close <= takeProfit1
            exitTrade := true

    // Auto close after 50 bars
    if barsInTrade > 50
        exitTrade := true

    // Close trade
    if exitTrade
        hasActiveTrade := false

        // Delete lines
        deleteLine(entryLine)
        deleteLine(stopLine)
        deleteLine(tp1Line)
        deleteLine(tp2Line)
        deleteLine(tp3Line)
        deleteLabel(entryLabel)
        deleteLabel(stopLabel)
        deleteLabel(tp1Label)

// ============================================
// SECTION 10: VISUALIZATION
// ============================================

// Plot EMAs
plot(showEMAs ? ema20 : na, "EMA 20", COLOR_INFO, lineWidth)
plot(showEMAs ? ema50 : na, "EMA 50", COLOR_WARNING, lineWidth)

// Plot Signals with cleanup
if longSignal and showLongSignals
    sizeValue = labelSize == "small" ? size.small : labelSize == "large" ? size.large : size.normal
    newLabel = label.new(bar_index, low, "BUY", yloc=yloc.belowbar, color=COLOR_BULLISH, textcolor=color.white, style=label.style_label_up, size=sizeValue, tooltip="Long Signal\nEntry: " + str.tostring(close, format.mintick))
    array.push(signalLabels, newLabel)
    cleanupSignalLabels()

if shortSignal and showShortSignals
    sizeValue = labelSize == "small" ? size.small : labelSize == "large" ? size.large : size.normal
    newLabel = label.new(bar_index, high, "SELL", yloc=yloc.abovebar, color=COLOR_BEARISH, textcolor=color.white, style=label.style_label_down, size=sizeValue, tooltip="Short Signal\nEntry: " + str.tostring(close, format.mintick))
    array.push(signalLabels, newLabel)
    cleanupSignalLabels()

// ============================================
// SECTION 11: INFO PANEL
// ============================================

var table infoTable = na

if showInfoPanel and barstate.islast
    if not na(infoTable)
        table.delete(infoTable)

    infoTable := table.new(position.bottom_right, 2, 6, bgcolor=color.new(COLOR_NEUTRAL, 90), border_width=1, border_color=color.gray)

    // Header
    table.cell(infoTable, 0, 0, "SVT v2.0", text_color=color.white, text_size=size.normal, bgcolor=color.new(COLOR_INFO, 70))
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Trend
    isUptrend = ema20 > ema50 and close > ema20
    isDowntrend = ema20 < ema50 and close < ema20
    trendText = isUptrend ? "UP" : isDowntrend ? "DOWN" : "SIDE"
    trendColor = isUptrend ? COLOR_BULLISH : isDowntrend ? COLOR_BEARISH : COLOR_NEUTRAL
    table.cell(infoTable, 0, 1, "Trend:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 1, trendText, text_color=trendColor, text_size=size.tiny)

    // Volume
    volStatus = isStrongSpike ? "HIGH" : isVolumeSpike ? "ELEVATED" : "Normal"
    volColor = isStrongSpike ? COLOR_WARNING : isVolumeSpike ? color.yellow : color.white
    table.cell(infoTable, 0, 2, "Volume:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 2, volStatus, text_color=volColor, text_size=size.tiny)

    // Accumulation
    accumStatus = isDrawingAccum ? "ACTIVE (" + str.tostring(accumBarsCount) + ")" : "None"
    accumColor = isDrawingAccum ? COLOR_INFO : COLOR_NEUTRAL
    table.cell(infoTable, 0, 3, "Accum:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 3, accumStatus, text_color=accumColor, text_size=size.tiny)

    // Active Trade
    tradeStatus = hasActiveTrade ? tradeDirection + " (" + str.tostring(barsInTrade) + ")" : "None"
    tradeColor = hasActiveTrade ? COLOR_INFO : COLOR_NEUTRAL
    table.cell(infoTable, 0, 4, "Trade:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 4, tradeStatus, text_color=tradeColor, text_size=size.tiny)

    // Confirmation Status
    confirmText = waitingConfirmation ? "WAIT " + breakoutType : "Ready"
    confirmColor = waitingConfirmation ? COLOR_WARNING : COLOR_NEUTRAL
    table.cell(infoTable, 0, 5, "Status:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 5, confirmText, text_color=confirmColor, text_size=size.tiny)

// ============================================
// SECTION 12: ALERTS
// ============================================

alertcondition(longSignal, "Long Entry", "BUY Signal - Confirmed Breakout!")
alertcondition(shortSignal, "Short Entry", "SELL Signal - Confirmed Breakdown!")
alertcondition(bearishDivergence, "Bearish Divergence", "Bearish Divergence - Possible Top!")
alertcondition(bullishDivergence, "Bullish Divergence", "Bullish Divergence - Possible Bottom!")
alertcondition(isDrawingAccum and not isDrawingAccum[1], "Accumulation Start", "Accumulation Zone Detected!")

// ============================================
// END OF INDICATOR v2.0
// ============================================

// CHANGELOG v2.0:
// - Reduced accumulation boxes (single box per zone)
// - Stricter divergence filters (30% volume decrease, 2% price change)
// - Breakout confirmation system
// - Optimized line/label management (no duplicates)
// - Info panel instead of multiple labels
// - Volume spike threshold increased to 3.0x
// - Limited divergence lines to max 3
// - Signal labels cleanup (max 10)
// - Removed trend background (replaced with info panel)
// - Overall 70% reduction in chart objects
