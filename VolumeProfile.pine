// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Leviathan

// Some Volume Profile elements are inspired by @LonesomeTheBlue's volume profile script

//@version=5
indicator("Volume profile && BB", overlay=true, max_boxes_count=500, max_bars_back=1000)

//==========================
//Inputs
//==========================
sessionType = input.string('Daily', 'Session Type', options=['Tokyo','London','New York','Daily','Weekly', 'Monthly', 'Quarterly', 'Yearly'])

showProf = input.bool(true, 'Show Volume Profile', group='Display')
showSbox = input.bool(true, 'Show Session Box', group='Display')
showPoc = input.bool(true, 'Show POC', group='Display')
showVA = input.bool(true, 'Show VAH and VAL', group='Display')
showVAb = input.bool(false, 'Show Value Area Box', group='Display')
showCur = input.bool(true, 'Show Live Zone', group='Display')
showLabels = input.bool(false, 'Show Session Lables', group='Display')
showFx = input.bool(false, 'Show Forex Sessions (no profile)', group='Display')
resolution = input.int(30, 'Resolution', minval=5, tooltip='The higher the value, the more refined of a profile, but less profiles shown on chart', group='Volume Profile Settings')
VAwid = input.int(70, 'Value Area Volume %', minval=1, maxval=100, group='Volume Profile Settings')
dispMode = input.string('Mode 2', 'Bar Mode', ['Mode 1', 'Mode 2', 'Mode 3'], group='Volume Profile Settings')
volType = input.string('Volume', 'Profile Data Type', options=['Volume', 'Open Interest'], group='Volume Profile Settings')
smoothVol = input.bool(false, 'Smooth Volume Data', tooltip='Useful for assets that have very large spikes in volume over large bars - helps create better profiles', group='Volume Profile Settings')
dataTf = ''

bullCol = input.color(color.rgb(76, 175, 79, 50), 'Up Volume', group='Appearance')
bearCol = input.color(color.rgb(255, 82, 82, 50), 'Down Volume', group='Appearance')
VAbCol = input.color(color.rgb(107, 159, 255, 90), 'Value Area Box', group='Appearance' )
pocCol = input.color(color.red, 'POC', inline='p', group='Appearance')
pocWid = input.int(1, 'Thickness', inline='p', group='Appearance')
vahCol = input.color(color.aqua, 'VAH', inline='h', group='Appearance')
vahWid = input.int(1, 'Thickness', inline='h', group='Appearance')
valCol = input.color(color.aqua, 'VAL', inline='l', group='Appearance')
valWid = input.int(1, 'Thickness', inline='l', group='Appearance')
boxBg = input.color(color.rgb(255, 153, 0, 100), 'Box', inline='m', group='Appearance')
boxWid = input.int(1, 'Thickness', inline='m', group='Appearance')

//==========================
//Constants / Variable Declaration
//========================== 
var int zoneStart = 0
var int tokyoStart = 0
var int londonStart = 0
var int nyStart = 0
int lookback = bar_index - zoneStart
var activeZone = false

// Defining arrays that store the information
var vpGreen = array.new_float(resolution, 0) // Sum of volume on long bars
var vpRed = array.new_float(resolution, 0) // Same thing but with red bars
var zoneBounds = array.new_float(resolution, 0) // array that stores the highest value that can be in a zone

//Values to store current intra bar data
var float[] ltfOpen =  array.new_float(0)
var float[] ltfClose =  array.new_float(0)
var float[] ltfHigh =  array.new_float(0)
var float[] ltfLow =  array.new_float(0)
var float[] ltfVolume = array.new_float(0)

//Getting OI Data
string userSymbol = syminfo.prefix + ":" + syminfo.ticker
string openInterestTicker = str.format("{0}_OI", userSymbol)
string timeframe = syminfo.type == "futures" and timeframe.isintraday ? "1D" : timeframe.period
deltaOi = request.security(openInterestTicker, timeframe, close-close[1], ignore_invalid_symbol = true)

//Selecting what vol type to use
vol() =>
    out = smoothVol ? ta.ema(volume, 5) : volume
    if volType == 'Open Interest'
        out := deltaOi
    out

//Getting intrabar intial data
[dO, dC, dH, dL, dV] = request.security_lower_tf(syminfo.tickerid, dataTf, [open, close, high, low, vol()])

//==========================
//Functions
//==========================
resetProfile(enable) =>
    if enable
        array.fill(vpGreen, 0)
        array.fill(vpRed, 0)
        array.clear(ltfOpen)
        array.clear(ltfHigh)
        array.clear(ltfLow)
        array.clear(ltfClose)
        array.clear(ltfVolume)

profHigh = ta.highest(high, lookback+1)[1]
profLow = ta.lowest(low, lookback+1)[1]

tr = ta.atr(1)
atr = ta.atr(14)

get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

profileAdd(o, h, l, c, v, g, w) =>
    //Array to store how much to distribute in each zone, on scale of 1 for full gap size to 0
    zoneDist = array.new_float(resolution, 0)
    distSum = 0.0
    // Going over each zone
    for i = 0 to array.size(vpGreen) - 1
        // Checking to see if cur bar is in zone
        zoneTop = array.get(zoneBounds, i)
        zoneBot = zoneTop - g

        body_top = math.max(c, o)
        body_bot = math.min(c, o)
        itsgreen = c >= o

        topwick = h - body_top
        bottomwick = body_bot - l
        body = body_top - body_bot

        bodyvol = body * v / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * v / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * v / (2 * topwick + 2 * bottomwick + body)

        if volType == 'Volume'
            array.set(vpGreen, i, array.get(vpGreen, i) + (itsgreen ? get_vol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol) : 0) + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
            array.set(vpRed, i, array.get(vpRed, i) + (itsgreen ? 0 : get_vol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol)) + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
        else if volType == 'Open Interest'
            if v > 0    
                array.set(vpGreen, i, array.get(vpGreen, i) + get_vol(zoneBot, zoneTop, body_bot, body_top, body, v))// + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
            if v < 0
                array.set(vpRed, i, array.get(vpRed, i) + get_vol(zoneBot, zoneTop, body_bot, body_top, body, -v))// + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)

calcSession(update) =>
    array.fill(vpGreen, 0)
    array.fill(vpRed, 0)
    if bar_index > lookback and update
        gap = (profHigh - profLow) / resolution

        // Defining profile bounds
        for i = 0 to resolution - 1
            array.set(zoneBounds, i, profHigh - gap * i)

        // Putting each bar inside zone into the volume profile array
        if array.size(ltfOpen) > 0
            for j = 0 to array.size(ltfOpen) - 1    
                profileAdd(array.get(ltfOpen, j), array.get(ltfHigh, j), array.get(ltfLow, j), array.get(ltfClose, j), array.get(ltfVolume, j), gap, 1)

pocLevel() =>
    float maxVol = 0
    int levelInd = 0
    for i = 0 to array.size(vpRed) - 1
        if array.get(vpRed, i) + array.get(vpGreen, i) > maxVol
            maxVol := array.get(vpRed, i) + array.get(vpGreen, i)
            levelInd := i
    
    float outLevel = na
    if levelInd != array.size(vpRed) - 1
        outLevel := array.get(zoneBounds, levelInd) - (array.get(zoneBounds, levelInd) - array.get(zoneBounds, levelInd+1)) / 2
    outLevel

valueLevels(poc) =>
    float gap = (profHigh - profLow) / resolution
    float volSum = array.sum(vpRed) + array.sum(vpGreen)
    float volCnt = 0
    
    float vah = profHigh
    float val = profLow

    //Finding poc index
    int pocInd = 0
    for i = 0 to array.size(zoneBounds)-2
        if array.get(zoneBounds, i) >= poc and array.get(zoneBounds, i + 1) < poc
            pocInd := i
    
    volCnt += (array.get(vpRed, pocInd) + array.get(vpGreen, pocInd))
    for i = 1 to array.size(vpRed)
        if pocInd + i >= 0 and pocInd + i < array.size(vpRed)    
            volCnt += (array.get(vpRed, pocInd + i) + array.get(vpGreen, pocInd + i))
            if volCnt >= volSum * (VAwid/100)    
                break 
            else
                val := array.get(zoneBounds, pocInd + i) - gap
        if pocInd - i >= 0 and pocInd - i < array.size(vpRed)    
            volCnt += (array.get(vpRed, pocInd - i) + array.get(vpGreen, pocInd - i))
            if volCnt >= volSum * (VAwid/100)    
                break 
            else
                vah := array.get(zoneBounds, pocInd - i)

    [val, vah]

drawNewZone(update) =>
    if bar_index > lookback and update and array.sum(vpGreen) + array.sum(vpRed) > 0
        gap = (profHigh - profLow) / resolution
        float leftMax = bar_index[lookback]
        float rightMax = bar_index[int(lookback / 1.4)]
        float rightMaxVol = array.max(vpGreen)+array.max(vpRed)
        float buffer = gap / 10
        if showLabels
            label.new((bar_index - 1 + int(leftMax))/2, profHigh, sessionType, color=color.rgb(0,0,0,100), textcolor=chart.fg_color)
        if showProf
            for i = 0 to array.size(vpRed) - 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(vpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(vpRed, i) / rightMaxVol))
                if dispMode == 'Mode 2'
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0)
                    box.new(greenEnd, array.get(zoneBounds, i) - buffer, redEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bearCol, border_width=0)
                else if dispMode == 'Mode 1'
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0)
                else 
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0)
                    box.new(int(leftMax)-redEnd+greenEnd, array.get(zoneBounds, i) - buffer, int(leftMax), array.get(zoneBounds, i) - gap + buffer, bgcolor=bearCol, border_width=0)

        // box.new(int(leftMax), profHigh, bar_index-1, profLow, chart.fg_color, boxWid, line.style_dashed, bgcolor=boxBg)
        poc = pocLevel()
        [val, vah] = valueLevels(poc)
        if showPoc
            line.new(int(leftMax), poc, bar_index-1, poc, color=pocCol, width=pocWid)
        if showVA
            line.new(int(leftMax), vah, bar_index-1, vah, color=vahCol, width=vahWid)
            line.new(int(leftMax), val, bar_index-1, val, color=valCol, width=valWid)
        if showVAb
            box.new(int(leftMax), vah, bar_index-1, val, border_color=color.rgb(54, 58, 69, 100), bgcolor=VAbCol)


    //if update    
    //    resetProfile(true)

drawCurZone(update, delete) =>
    var line pocLine = na
    var line vahLine = na
    var line valLine = na
    var box outBox = na
    var label sessionLab = na

    var redBoxes = array.new_box(array.size(vpRed), na)
    var greenBoxes = array.new_box(array.size(vpRed), na)

    if bar_index > lookback and update and array.sum(vpGreen) + array.sum(vpRed) > 0
        //Clearing the previous boxes and array
        if not na(pocLine)
            line.delete(pocLine)
        if not na(vahLine)
            line.delete(vahLine)
        if not na(valLine)
            line.delete(valLine)
        if not na(outBox)
            box.delete(outBox)
        if not na(sessionLab)
            label.delete(sessionLab)

        for i = 0 to array.size(redBoxes) - 1
            if not na(array.get(redBoxes, i))
                box.delete(array.get(redBoxes, i))
                box.delete(array.get(greenBoxes, i))

        
        gap = (profHigh - profLow) / resolution
        float leftMax = bar_index[lookback]
        float rightMax = bar_index[int(lookback / 1.4)]
        float rightMaxVol = array.max(vpGreen)+array.max(vpRed)
        float buffer = gap / 10
        if showLabels
            sessionLab := label.new((bar_index - 1 + int(leftMax))/2, profHigh, sessionType, color=color.rgb(0,0,0,100), textcolor=chart.fg_color)
        if showProf
            for i = 0 to array.size(vpRed) - 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(vpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(vpRed, i) / rightMaxVol))
                if dispMode == 'Mode 2'
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0))
                    array.set(redBoxes, i, box.new(greenEnd, array.get(zoneBounds, i) - buffer, redEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bearCol, border_width=0))
                else if dispMode == 'Mode 1'
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0))
                else 
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor=bullCol, border_width=0))
                    array.set(redBoxes, i, box.new(int(leftMax)-redEnd+greenEnd, array.get(zoneBounds, i) - buffer, int(leftMax), array.get(zoneBounds, i) - gap + buffer, bgcolor=bearCol, border_width=0))
        
        // outBox := box.new(int(leftMax), profHigh, bar_index-1, profLow, chart.fg_color, boxWid, line.style_dashed, bgcolor=boxBg)
        outBox := na
        

        poc = pocLevel()
        [val, vah] = valueLevels(poc)
        if showPoc    
            line.delete(pocLine)
            pocLine := line.new(int(leftMax), poc, bar_index-1, poc, color=pocCol, width=pocWid)
        if showVA
            line.delete(vahLine)
            line.delete(valLine)            
            vahLine := line.new(int(leftMax), vah, bar_index-1, vah, color=vahCol, width=vahWid)
            valLine := line.new(int(leftMax), val, bar_index-1, val, color=valCol, width=valWid)
        if showVAb
            box.new(int(leftMax), vah, bar_index-1, val, border_color=color.rgb(54, 58, 69, 100), bgcolor=VAbCol)

    if delete
        box.delete(outBox)
        line.delete(pocLine)
        line.delete(vahLine)
        line.delete(valLine)
        for i = 0 to array.size(greenBoxes)-1
            box.delete(array.get(greenBoxes, i))
        for i = 0 to array.size(redBoxes)-1
            box.delete(array.get(redBoxes, i))

drawForexBox(startBar, title, top, bottom) =>
    // box.new(int(startBar), top, bar_index-1, bottom, chart.fg_color, boxWid, line.style_dashed, bgcolor=boxBg)
    if showLabels    
        label.new((bar_index - 1 + int(startBar))/2, top, title, color=color.rgb(0,0,0,100), textcolor=chart.fg_color)
    

combArray(arr1, arr2) =>
    out = array.copy(arr1)
    if array.size(arr2) > 0
        for i = 0 to array.size(arr2) - 1
            array.push(out, array.get(arr2, i))
    out

updateIntra(o, h, l, c, v) =>
    if array.size(o) > 0
        for i = 0 to array.size(o) - 1
            array.push(ltfOpen, array.get(o, i))
            array.push(ltfHigh,array.get(h, i)) 
            array.push(ltfLow,array.get(l, i)) 
            array.push(ltfClose,array.get(c, i)) 
            array.push(ltfVolume,array.get(v, i))
    

//==========================
//Calculations
//==========================
//Detecting different start dates
// newDaily = dayofweek(time,"UTC-4") != dayofweek(time,"UTC-4")[1]
newDaily = dayofweek(time,"UTC") != dayofweek(time,"UTC")[1]
newWeekly = weekofyear != weekofyear[1]
newMonthly = (dayofmonth != dayofmonth[1] + 1) and (dayofmonth != dayofmonth[1])
newYearly = year != year[1]
newQuarterly = month != month[1] and (month - 1) % 3 == 0

utcHour = hour(time(timeframe.period, '0000-2400', 'UTC-4'), 'UTC-4')

// newTokyo = utcHour != utcHour[1] + 1 and utcHour != utcHour[1]
newTokyo = utcHour >= 22 and utcHour[1] < 22
endTokyo = utcHour >= 7 and utcHour[1] < 7

newLondon = utcHour >= 7 and utcHour[1] < 7
endLondon = utcHour >= 16 and utcHour[1] < 16

newNewYork = utcHour >= 12 and utcHour[1] < 12
endNewYork = utcHour >= 21 and utcHour[1] < 21

newSession = switch sessionType
    'Tokyo' => newTokyo
    'London' => newLondon
    'New York' => newNewYork
    'Daily' => newDaily
    'Weekly' => newWeekly
    'Monthly' => newMonthly
    'Yearly' => newYearly
    'Quarterly' => newQuarterly
    => newDaily

zoneEnd = switch sessionType
    'Tokyo' => endTokyo
    'London' => endLondon
    'New York' => endNewYork
    'Daily' => newDaily
    'Weekly' => newWeekly
    'Monthly' => newMonthly
    'Yearly' => newYearly
    'Quarterly' => newQuarterly
    => newDaily

isForex = showFx

//Re calculating and drawing zones
calcSession(zoneEnd or (barstate.islast and showCur))
drawNewZone(zoneEnd)
// calcSession(endTokyo or (barstate.islast and showCur))
// calcSession(endLondon or (barstate.islast and showCur))
// calcSession(endNewYork or (barstate.islast and showCur))
// drawNewZone(endTokyo)
// drawNewZone(endLondon)
// drawNewZone(endNewYork)
// drawCurZone(barstate.islast and not endTokyo and showCur and activeZone, endTokyo)
// drawCurZone(barstate.islast and not endLondon and showCur and activeZone, endLondon)
// drawCurZone(barstate.islast and not endNewYork and showCur and activeZone, endNewYork)
drawCurZone(barstate.islast and not zoneEnd and showCur and activeZone, zoneEnd)

//Reseting profie at start of new zone
resetProfile(newSession)
// resetProfile(newTokyo)
// resetProfile(newLondon)
// resetProfile(newNewYork)

//Updating data arrays
updateIntra(dO, dH, dL, dC, dV)

//Reseting zone start value
if zoneEnd 
    activeZone := false

if newSession
    zoneStart := bar_index
    activeZone := true

if newLondon
    londonStart := bar_index 
if newTokyo
    tokyoStart := bar_index 
if newNewYork
    nyStart := bar_index

londonHigh = ta.highest(high, bar_index-londonStart+1)
tokyoHigh = ta.highest(high, bar_index-tokyoStart+1)
nyHigh = ta.highest(high, bar_index-nyStart+1)

londonLow = ta.lowest(low, bar_index-londonStart+1)
tokyoLow = ta.lowest(low, bar_index-tokyoStart+1)
nyLow = ta.lowest(low, bar_index-nyStart+1)

if endLondon and isForex
    drawForexBox(londonStart, 'London', londonHigh, londonLow)
if endNewYork and isForex
    drawForexBox(nyStart, 'New York', nyHigh, nyLow)
if endTokyo and isForex
    drawForexBox(tokyoStart, 'Tokyo', tokyoHigh, tokyoLow)

// drawForexBox(londonStart, 'London', londonHigh, londonLow)
// drawForexBox(nyStart, 'New York', nyHigh, nyLow)
// drawForexBox(tokyoStart, 'Tokyo', tokyoHigh, tokyoLow)
///////////// RSI
RSIlength = input(6,title="RSI Period Length") 
RSIoverSold = 70
RSIoverBought = 30
price = close
vrsi = ta.rsi(price, RSIlength)


///////////// Bollinger Bands
BBlength = input.int(20, minval=1, title="Bollinger Period Length")
BBmult = 2 // input(2.0, minval=0.001, maxval=50,title="Bollinger Bands Standard Deviation")
BBbasis = ta.sma(price, BBlength)
BBdev = BBmult * ta.stdev(price, BBlength)
BBupper = BBbasis + BBdev
BBlower = BBbasis - BBdev
source = close
source_1 = low
buyEntry = ta.crossover(source, BBlower)
sellEntry = ta.crossunder(source, BBupper)
sellEntry_1 = ta.crossunder(source_1, BBupper)
plot(BBbasis, color=color.rgb(67, 223, 231, 52),title="Bollinger Bands SMA Basis Line", display = display.none)
p1 = plot(BBupper, color=color.rgb(255, 46, 46),title="Bollinger Bands Upper Line", display = display.none)
p2 = plot(BBlower, color=color.rgb(255, 46, 46),title="Bollinger Bands Lower Line", display = display.none)
fill(p1, p2, title = "Background BB20", color=color.rgb(243, 229, 33, 66), display = display.none)

///////////// Bollinger Bands
BBlength_1 = input.int(30, minval=1, title="Bollinger Period Length 1")
BBmult_1 = 3 // input(2.0, minval=0.001, maxval=50,title="Bollinger Bands Standard Deviation")
BBbasis_1 = ta.sma(price, BBlength_1)
BBdev_1 = BBmult_1 * ta.stdev(price, BBlength_1)
BBupper_1 = BBbasis_1 + BBdev_1
BBlower_1 = BBbasis_1 - BBdev_1
plot(BBbasis_1, color=color.rgb(212, 0, 0),title="Bollinger Bands 30", display = display.none)
p1_1 = plot(BBupper_1, color=color.rgb(59, 92, 190, 75),title="Upper Bands 30", display = display.none)
p2_1 = plot(BBlower_1, color=color.rgb(71, 93, 159),title="Lower Bands 30", display = display.none)
fill(p1_1, p2_1, title = "Background BB30", color=color.rgb(35, 191, 188, 62), display = display.none)

shortest = ta.ema(close, 9)
short = ta.ema(close, 12)
longer = ta.ema(close, 26)
longest = ta.ema(close, 50)

plot(shortest, color = color.red, title="EMA 9", display = display.none)
plot(short, color = color.orange, title="EMA 12", display = display.none)
plot(longer, color = color.aqua, title="EMA 26", display = display.none)
plot(longest, color = color.blue, title="EMA 50", display = display.none)


hideonDWM = input(false, title="Hide VWAP on 1D or Above", group="VWAP Settings")
var anchor = input.string(defval = "Session", title="Anchor Period",
 options=["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group="VWAP Settings")
src = input(title = "Source", defval = hlc3, group="VWAP Settings")
offset = input(0, title="Offset", group="VWAP Settings")

showBand_1 = input(false, title="", group="Standard Deviation Bands Settings", inline="band_1")
stdevMult_1 = input(1.0, title="Bands Multiplier #1", group="Standard Deviation Bands Settings", inline="band_1")
showBand_2 = input(false, title="", group="Standard Deviation Bands Settings", inline="band_2")
stdevMult_2 = input(2.0, title="Bands Multiplier #2", group="Standard Deviation Bands Settings", inline="band_2")
showBand_3 = input(false, title="", group="Standard Deviation Bands Settings", inline="band_3")
stdevMult_3 = input(3.0, title="Bands Multiplier #3", group="Standard Deviation Bands Settings", inline="band_3")

if barstate.islast and ta.cum(volume) == 0
    runtime.error("No volume is provided by the data vendor.")

new_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)

isNewPeriod = switch anchor
	"Earnings"  => not na(new_earnings)
	"Dividends" => not na(new_dividends)
	"Splits"    => not na(new_split)
	"Session"   => timeframe.change("D")
	"Week"      => timeframe.change("W")
	"Month"     => timeframe.change("M")
	"Quarter"   => timeframe.change("3M")
	"Year"      => timeframe.change("12M")
	"Decade"    => timeframe.change("12M") and year % 10 == 0
	"Century"   => timeframe.change("12M") and year % 100 == 0
	=> false

isEsdAnchor = anchor == "Earnings" or anchor == "Dividends" or anchor == "Splits"
if na(src[1]) and not isEsdAnchor
	isNewPeriod := true

float vwapValue = na
float upperBandValue1 = na
float lowerBandValue1 = na
float upperBandValue2 = na
float lowerBandValue2 = na
float upperBandValue3 = na
float lowerBandValue3 = na

if not (hideonDWM and timeframe.isdwm)
    [_vwap, _stdevUpper, _] = ta.vwap(src, isNewPeriod, 1)
	vwapValue := _vwap
    stdevAbs = _stdevUpper - _vwap
	upperBandValue1 := _vwap + stdevAbs * stdevMult_1
	lowerBandValue1 := _vwap - stdevAbs * stdevMult_1
	upperBandValue2 := _vwap + stdevAbs * stdevMult_2
	lowerBandValue2 := _vwap - stdevAbs * stdevMult_2
	upperBandValue3 := _vwap + stdevAbs * stdevMult_3
	lowerBandValue3 := _vwap - stdevAbs * stdevMult_3

plot(vwapValue, title="VWAP", color=#2962FF, offset=offset)

upperBand_1 = plot(upperBandValue1, title="Upper Band #1", color=color.green, offset=offset, display = showBand_1 ? display.all : display.none)
lowerBand_1 = plot(lowerBandValue1, title="Lower Band #1", color=color.green, offset=offset, display = showBand_1 ? display.all : display.none)
fill(upperBand_1, lowerBand_1, title="Bands Fill #1", color= color.new(color.green, 95)    , display = showBand_1 ? display.all : display.none)

upperBand_2 = plot(upperBandValue2, title="Upper Band #2", color=color.olive, offset=offset, display = showBand_2 ? display.all : display.none)
lowerBand_2 = plot(lowerBandValue2, title="Lower Band #2", color=color.olive, offset=offset, display = showBand_2 ? display.all : display.none)
fill(upperBand_2, lowerBand_2, title="Bands Fill #2", color= color.new(color.olive, 95)    , display = showBand_2 ? display.all : display.none)

upperBand_3 = plot(upperBandValue3, title="Upper Band #3", color=color.teal, offset=offset, display = showBand_3 ? display.all : display.none)
lowerBand_3 = plot(lowerBandValue3, title="Lower Band #3", color=color.teal, offset=offset, display = showBand_3 ? display.all : display.none)
fill(upperBand_3, lowerBand_3, title="Bands Fill #3", color= color.new(color.teal, 95)    , display = showBand_3 ? display.all : display.none)


ema200 = ta.ema(close, 200)

plot(ema200, color = color.red, title="EMA 200", display = display.none)
