// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © pmbibe

//@version=6
indicator("Tape Reading Pro - Order Flow Analysis", shorttitle="TapeReadingPro", overlay=true, max_bars_back=500, max_labels_count=500)

// ═══════════════════════════════════════════════════════════════════════════════
// TAPE READING FOUNDATIONS
// ═══════════════════════════════════════════════════════════════════════════════
// This indicator decodes institutional order flow by analyzing:
// 1. PRICE: Movement direction, speed, and tick behavior
// 2. VOLUME: Traded volume, spikes, and absorption patterns
// 3. TIME: Duration at price levels and consolidation periods
//
// Key Tape Behaviors Detected:
// - Aggressive Buying/Selling (Initiative Orders)
// - Absorption (Smart Money Accumulation/Distribution)
// - Exhaustion (Climax Volume & Reversals)
// - Initiative vs Responsive Orders
// - Fake vs Real Breakouts

// ═══════════════════════════════════════════════════════════════════════════════
// USER INPUTS
// ═══════════════════════════════════════════════════════════════════════════════

// === MODULE TOGGLES ===
group_modules = "═══ MODULE TOGGLES ═══"
show_aggressive = input.bool(true, "Show Aggressive Orders", group=group_modules, tooltip="Detect initiative buying/selling with fast price movement and high volume")
show_absorption = input.bool(true, "Show Absorption Zones", group=group_modules, tooltip="Identify areas where Smart Money is accumulating/distributing (high volume, minimal price movement)")
show_exhaustion = input.bool(true, "Show Exhaustion Signals", group=group_modules, tooltip="Detect climax volume followed by reversals")
show_delta_histogram = input.bool(true, "Show Volume Delta Histogram", group=group_modules, tooltip="Display estimated buying/selling pressure")
show_labels = input.bool(true, "Show Event Labels", group=group_modules, tooltip="Display labels for key tape reading events")
show_candle_colors = input.bool(true, "Color Candles by Tape Condition", group=group_modules, tooltip="Override candle colors based on order flow")

// === VOLUME PARAMETERS ===
group_volume = "═══ VOLUME PARAMETERS ═══"
volume_ma_length = input.int(20, "Volume MA Length", minval=5, maxval=100, group=group_volume, tooltip="Period for average volume calculation")
high_volume_threshold = input.float(2.0, "High Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group=group_volume, tooltip="Multiplier of average volume to detect high volume (2.0 = 200% of average)")
extreme_volume_threshold = input.float(3.0, "Extreme Volume Threshold", minval=2.0, maxval=10.0, step=0.5, group=group_volume, tooltip="Multiplier for exhaustion detection (3.0 = 300% of average)")

// === ABSORPTION PARAMETERS ===
group_absorption = "═══ ABSORPTION PARAMETERS ═══"
absorption_sensitivity = input.float(1.5, "Absorption Sensitivity", minval=0.5, maxval=5.0, step=0.1, group=group_absorption, tooltip="Higher values = stricter absorption detection. Measures volume/spread ratio.")
absorption_lookback = input.int(3, "Absorption Lookback", minval=1, maxval=10, group=group_absorption, tooltip="Number of bars to confirm absorption pattern")

// === INITIATIVE PARAMETERS ===
group_initiative = "═══ INITIATIVE PARAMETERS ═══"
initiative_threshold = input.float(1.5, "Initiative Score Threshold", minval=1.0, maxval=3.0, step=0.1, group=group_initiative, tooltip="Minimum score to flag aggressive orders (combines body strength with volume)")
velocity_lookback = input.int(5, "Price Velocity Lookback", minval=3, maxval=20, group=group_initiative, tooltip="Period to measure price movement speed")

// === EXHAUSTION PARAMETERS ===
group_exhaustion = "═══ EXHAUSTION PARAMETERS ═══"
exhaustion_reversal_bars = input.int(3, "Exhaustion Reversal Bars", minval=1, maxval=5, group=group_exhaustion, tooltip="Number of reversal bars after climax volume to confirm exhaustion")

// === VISUAL SETTINGS ===
group_visual = "═══ VISUAL SETTINGS ═══"
color_aggressive_buy = input.color(color.new(color.green, 0), "Aggressive Buy", group=group_visual)
color_aggressive_sell = input.color(color.new(color.red, 0), "Aggressive Sell", group=group_visual)
color_absorption = input.color(color.new(color.blue, 0), "Absorption", group=group_visual)
color_exhaustion = input.color(color.new(color.orange, 0), "Exhaustion", group=group_visual)
color_delta_buy = input.color(color.new(color.lime, 60), "Delta Buy Pressure", group=group_visual)
color_delta_sell = input.color(color.new(color.maroon, 60), "Delta Sell Pressure", group=group_visual)

// === ENTRY MANAGEMENT MODULE ===
group_entry = "═══ ENTRY MANAGEMENT ═══"
show_entry_management = input.bool(true, "Show Entry Management", group=group_entry, tooltip="Display entry, stop loss, and take profit levels")
reset_on_opposite_signal = input.bool(true, "Reset on Opposite Signal", group=group_entry, tooltip="Clear current setup when opposite signal appears")

// === STOP LOSS SETTINGS ===
group_sl = "═══ STOP LOSS SETTINGS ═══"
sl_type = input.string("Percentage", "Stop Loss Type", options=["Percentage", "ATR", "Swing Point"], group=group_sl, tooltip="Method for calculating stop loss distance")
sl_percentage = input.float(2.0, "SL Percentage", minval=0.1, maxval=20.0, step=0.1, group=group_sl, tooltip="Stop loss distance as percentage of entry price")
sl_atr_multiplier = input.float(1.5, "SL ATR Multiplier", minval=0.5, maxval=5.0, step=0.1, group=group_sl, tooltip="ATR multiplier for stop loss distance")
sl_atr_length = input.int(14, "SL ATR Length", minval=5, maxval=50, group=group_sl, tooltip="ATR period for stop loss calculation")
sl_swing_lookback = input.int(10, "Swing Lookback", minval=3, maxval=50, group=group_sl, tooltip="Number of bars to look back for swing high/low")

// === TAKE PROFIT SETTINGS ===
group_tp = "═══ TAKE PROFIT SETTINGS ═══"
tp_type = input.string("Risk:Reward", "Take Profit Type", options=["Percentage", "Risk:Reward", "Fixed Points"], group=group_tp, tooltip="Method for calculating take profit levels")
tp_percentage = input.float(4.0, "TP Percentage", minval=0.1, maxval=50.0, step=0.1, group=group_tp, tooltip="Take profit distance as percentage of entry price")
tp_rr_ratio = input.float(2.0, "Risk:Reward Ratio", minval=0.5, maxval=10.0, step=0.1, group=group_tp, tooltip="Take profit as multiple of risk (e.g., 2.0 = 1:2 R:R)")
tp_fixed_points = input.float(100.0, "TP Fixed Points", minval=1.0, maxval=10000.0, step=1.0, group=group_tp, tooltip="Fixed point distance for take profit")
use_multiple_tps = input.bool(true, "Use Multiple TPs", group=group_tp, tooltip="Enable TP1, TP2, TP3 levels")
tp2_multiplier = input.float(1.5, "TP2 Multiplier", minval=1.1, maxval=5.0, step=0.1, group=group_tp, tooltip="Multiplier for TP2 (relative to TP1 distance)")
tp3_multiplier = input.float(2.5, "TP3 Multiplier", minval=1.5, maxval=10.0, step=0.1, group=group_tp, tooltip="Multiplier for TP3 (relative to TP1 distance)")

// === ENTRY VISUAL SETTINGS ===
group_entry_visual = "═══ ENTRY VISUALS ═══"
color_long_setup = input.color(color.new(color.green, 0), "Long Setup Color", group=group_entry_visual)
color_short_setup = input.color(color.new(color.red, 0), "Short Setup Color", group=group_entry_visual)
color_sl = input.color(color.new(color.red, 30), "Stop Loss Color", group=group_entry_visual)
color_tp = input.color(color.new(color.teal, 30), "Take Profit Color", group=group_entry_visual)
line_width_entry = input.int(2, "Entry Line Width", minval=1, maxval=4, group=group_entry_visual)
line_width_sl_tp = input.int(1, "SL/TP Line Width", minval=1, maxval=4, group=group_entry_visual)
show_signals_table = input.bool(true, "Show Signals Table", group=group_entry_visual, tooltip="Display trade management information table")

// ═══════════════════════════════════════════════════════════════════════════════
// CORE TAPE READING CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════

// === BASIC METRICS ===
candle_body = math.abs(close - open)
candle_range = high - low
candle_direction = close >= open ? 1 : -1

// Avoid division by zero
candle_range_safe = candle_range == 0 ? 0.0000001 : candle_range

// === VOLUME ANALYSIS ===
volume_ma = ta.sma(volume, volume_ma_length)
volume_ratio = volume_ma == 0 ? 0 : volume / volume_ma

// === VOLUME DELTA ESTIMATION ===
// Since TradingView doesn't have real delta, we estimate it using close position within candle
// Bullish candle closing near high = buying pressure
// Bearish candle closing near low = selling pressure
close_position = (close - low) / candle_range_safe  // 0 to 1, where 1 = close at high
delta_estimate = (close_position - 0.5) * 2 * volume  // -volume to +volume
// Alternative: simple delta based on candle direction
delta_simple = candle_direction * volume

// Combine both methods with weight toward close position
volume_delta = (delta_estimate * 0.7) + (delta_simple * 0.3)

// === PRICE VELOCITY ===
// Measures how fast price is moving (initiative orders move price quickly)
price_change = math.abs(close - close[velocity_lookback])
price_velocity = price_change / velocity_lookback

// === ABSORPTION RATIO ===
// High volume with minimal price movement = absorption
// Formula: Volume / (High - Low)
// Higher ratio = more absorption (lots of volume but price not moving)
absorption_ratio = volume / candle_range_safe

// Normalize absorption ratio by comparing to recent average
absorption_ratio_ma = ta.sma(absorption_ratio, absorption_lookback)
absorption_normalized = absorption_ratio_ma == 0 ? 0 : absorption_ratio / absorption_ratio_ma

// === INITIATIVE SCORE ===
// Combines candle body strength with volume to detect aggressive orders
// Strong body + high volume = initiative orders
body_strength = candle_body / candle_range_safe  // Wicks indicate responsive orders, body indicates initiative
initiative_score = body_strength * volume_ratio

// === EXHAUSTION DETECTION ===
// Extreme volume followed by reversal = exhaustion
is_extreme_volume = volume_ratio >= extreme_volume_threshold

// Check if next bars reverse (for exhaustion confirmation)
// Note: This uses future data for confirmation, but clearly marked as such
is_bullish_exhaustion = is_extreme_volume and candle_direction == 1 and ta.falling(close, exhaustion_reversal_bars)
is_bearish_exhaustion = is_extreme_volume and candle_direction == -1 and ta.rising(close, exhaustion_reversal_bars)
is_exhaustion = is_bullish_exhaustion or is_bearish_exhaustion

// For real-time (non-repainting) exhaustion, we flag when extreme volume appears
// Traders can watch for reversal in next bars
is_exhaustion_warning = is_extreme_volume and not is_exhaustion[1]

// ═══════════════════════════════════════════════════════════════════════════════
// TAPE BEHAVIOR DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

// === AGGRESSIVE BUYING/SELLING (Initiative Orders) ===
is_aggressive_buy = show_aggressive and
                     candle_direction == 1 and
                     initiative_score > initiative_threshold and
                     volume_ratio > high_volume_threshold and
                     close_position > 0.7  // Close near high

is_aggressive_sell = show_aggressive and
                      candle_direction == -1 and
                      initiative_score > initiative_threshold and
                      volume_ratio > high_volume_threshold and
                      close_position < 0.3  // Close near low

// === ABSORPTION DETECTION ===
// High volume but narrow range = Smart Money absorbing orders
is_absorption = show_absorption and
                 absorption_normalized > absorption_sensitivity and
                 volume_ratio > high_volume_threshold

// Confirm absorption over multiple bars for stronger signal
absorption_count = 0
for i = 0 to absorption_lookback - 1
    if absorption_normalized[i] > absorption_sensitivity and volume_ratio[i] > high_volume_threshold
        absorption_count := absorption_count + 1

is_strong_absorption = is_absorption and absorption_count >= 2

// === EXHAUSTION ===
show_exhaustion_signal = show_exhaustion and is_exhaustion_warning

// ═══════════════════════════════════════════════════════════════════════════════
// ENTRY MANAGEMENT - STOP LOSS & TAKE PROFIT CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════

// === ATR FOR STOP LOSS ===
atr_value = ta.atr(sl_atr_length)

// === SWING POINT DETECTION ===
// Find recent swing lows for long SL
swing_low = ta.lowest(low, sl_swing_lookback)
// Find recent swing highs for short SL
swing_high = ta.highest(high, sl_swing_lookback)

// === PERSISTENT VARIABLES FOR ENTRY TRACKING ===
var int signal_direction = 0          // 1 = Long, -1 = Short, 0 = No position
var float entry_price = na
var int entry_bar = na
var float stop_loss_price = na
var float take_profit_1 = na
var float take_profit_2 = na
var float take_profit_3 = na
var float risk_amount = na
var bool tp1_hit = false
var bool tp2_hit = false
var bool tp3_hit = false
var bool sl_hit = false

// === LINE VARIABLES ===
var line entry_line = na
var line sl_line = na
var line tp1_line = na
var line tp2_line = na
var line tp3_line = na

// === LABEL VARIABLES ===
var label entry_label = na
var label sl_label = na
var label tp1_label = na
var label tp2_label = na
var label tp3_label = na

// === STOP LOSS CALCULATION FUNCTION ===
calc_stop_loss(bool is_long, float entry) =>
    float sl = na
    if sl_type == "Percentage"
        sl := is_long ? entry * (1 - sl_percentage / 100) : entry * (1 + sl_percentage / 100)
    else if sl_type == "ATR"
        sl := is_long ? entry - (atr_value * sl_atr_multiplier) : entry + (atr_value * sl_atr_multiplier)
    else if sl_type == "Swing Point"
        // For long: use recent swing low minus buffer
        // For short: use recent swing high plus buffer
        float buffer = atr_value * 0.1  // Small buffer beyond swing point
        sl := is_long ? swing_low - buffer : swing_high + buffer
    sl

// === TAKE PROFIT CALCULATION FUNCTION ===
calc_take_profit(bool is_long, float entry, float sl, float tp_dist) =>
    float tp = na
    if tp_type == "Percentage"
        tp := is_long ? entry * (1 + tp_percentage / 100) : entry * (1 - tp_percentage / 100)
    else if tp_type == "Risk:Reward"
        float risk = math.abs(entry - sl)
        tp := is_long ? entry + (risk * tp_rr_ratio * tp_dist) : entry - (risk * tp_rr_ratio * tp_dist)
    else if tp_type == "Fixed Points"
        float tick_size = syminfo.mintick
        tp := is_long ? entry + (tp_fixed_points * tick_size * tp_dist) : entry - (tp_fixed_points * tick_size * tp_dist)
    tp

// === CHECK IF LEVELS ARE HIT (inline to modify global vars) ===
if show_entry_management and signal_direction == 1  // Long position
    if not na(stop_loss_price) and low <= stop_loss_price
        sl_hit := true
    if not na(take_profit_1) and high >= take_profit_1
        tp1_hit := true
    if not na(take_profit_2) and high >= take_profit_2
        tp2_hit := true
    if not na(take_profit_3) and high >= take_profit_3
        tp3_hit := true

if show_entry_management and signal_direction == -1  // Short position
    if not na(stop_loss_price) and high >= stop_loss_price
        sl_hit := true
    if not na(take_profit_1) and low <= take_profit_1
        tp1_hit := true
    if not na(take_profit_2) and low <= take_profit_2
        tp2_hit := true
    if not na(take_profit_3) and low <= take_profit_3
        tp3_hit := true

// === ENTRY SIGNAL PROCESSING ===
if show_entry_management

    // Reset position if SL or all TPs hit
    bool should_reset = sl_hit or (tp1_hit and tp2_hit and tp3_hit and use_multiple_tps) or (tp1_hit and not use_multiple_tps)

    // New Long Entry Signal
    if is_aggressive_buy and (signal_direction != 1 or should_reset)
        // Reset on opposite signal if enabled
        if reset_on_opposite_signal or signal_direction == 0 or should_reset
            // Delete old visuals inline
            line.delete(entry_line)
            line.delete(sl_line)
            line.delete(tp1_line)
            line.delete(tp2_line)
            line.delete(tp3_line)
            label.delete(entry_label)
            label.delete(sl_label)
            label.delete(tp1_label)
            label.delete(tp2_label)
            label.delete(tp3_label)

            signal_direction := 1
            entry_price := close
            entry_bar := bar_index
            stop_loss_price := calc_stop_loss(true, entry_price)
            risk_amount := entry_price - stop_loss_price
            take_profit_1 := calc_take_profit(true, entry_price, stop_loss_price, 1.0)
            take_profit_2 := use_multiple_tps ? calc_take_profit(true, entry_price, stop_loss_price, tp2_multiplier) : na
            take_profit_3 := use_multiple_tps ? calc_take_profit(true, entry_price, stop_loss_price, tp3_multiplier) : na
            tp1_hit := false
            tp2_hit := false
            tp3_hit := false
            sl_hit := false

    // New Short Entry Signal
    if is_aggressive_sell and (signal_direction != -1 or should_reset)
        if reset_on_opposite_signal or signal_direction == 0 or should_reset
            // Delete old visuals inline
            line.delete(entry_line)
            line.delete(sl_line)
            line.delete(tp1_line)
            line.delete(tp2_line)
            line.delete(tp3_line)
            label.delete(entry_label)
            label.delete(sl_label)
            label.delete(tp1_label)
            label.delete(tp2_label)
            label.delete(tp3_label)

            signal_direction := -1
            entry_price := close
            entry_bar := bar_index
            stop_loss_price := calc_stop_loss(false, entry_price)
            risk_amount := stop_loss_price - entry_price
            take_profit_1 := calc_take_profit(false, entry_price, stop_loss_price, 1.0)
            take_profit_2 := use_multiple_tps ? calc_take_profit(false, entry_price, stop_loss_price, tp2_multiplier) : na
            take_profit_3 := use_multiple_tps ? calc_take_profit(false, entry_price, stop_loss_price, tp3_multiplier) : na
            tp1_hit := false
            tp2_hit := false
            tp3_hit := false
            sl_hit := false

// ═══════════════════════════════════════════════════════════════════════════════
// ENTRY MANAGEMENT VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

// === DRAW LINES AND LABELS ===
if show_entry_management and signal_direction != 0 and not na(entry_price)
    // Determine colors based on direction
    color setup_color = signal_direction == 1 ? color_long_setup : color_short_setup
    string direction_text = signal_direction == 1 ? "LONG" : "SHORT"

    // Calculate R:R ratio for labels
    float current_rr = not na(risk_amount) and risk_amount != 0 ? math.abs(take_profit_1 - entry_price) / risk_amount : 0

    // Delete old lines to update positions
    line.delete(entry_line)
    line.delete(sl_line)
    line.delete(tp1_line)
    line.delete(tp2_line)
    line.delete(tp3_line)
    label.delete(entry_label)
    label.delete(sl_label)
    label.delete(tp1_label)
    label.delete(tp2_label)
    label.delete(tp3_label)

    // Entry Line (solid)
    entry_line := line.new(entry_bar, entry_price, bar_index + 10, entry_price,
                           color=setup_color, width=line_width_entry, style=line.style_solid)
    entry_label := label.new(bar_index + 11, entry_price,
                             direction_text + " Entry: " + str.tostring(entry_price, format.mintick),
                             style=label.style_label_left, color=setup_color, textcolor=color.white, size=size.small)

    // Stop Loss Line (dashed)
    color sl_line_color = sl_hit ? color.new(color_sl, 70) : color_sl
    sl_line := line.new(entry_bar, stop_loss_price, bar_index + 10, stop_loss_price,
                        color=sl_line_color, width=line_width_sl_tp, style=line.style_dashed)
    float sl_distance_pct = math.abs(entry_price - stop_loss_price) / entry_price * 100
    string sl_status = sl_hit ? " [HIT]" : ""
    sl_label := label.new(bar_index + 11, stop_loss_price,
                          "SL: " + str.tostring(stop_loss_price, format.mintick) + " (-" + str.tostring(sl_distance_pct, "#.##") + "%)" + sl_status,
                          style=label.style_label_left, color=sl_line_color, textcolor=color.white, size=size.tiny)

    // Take Profit 1 Line (dotted)
    if not na(take_profit_1)
        color tp1_color = tp1_hit ? color.new(color_tp, 70) : color_tp
        tp1_line := line.new(entry_bar, take_profit_1, bar_index + 10, take_profit_1,
                             color=tp1_color, width=line_width_sl_tp, style=line.style_dotted)
        float tp1_rr = not na(risk_amount) and risk_amount != 0 ? math.abs(take_profit_1 - entry_price) / risk_amount : 0
        string tp1_status = tp1_hit ? " [HIT]" : ""
        tp1_label := label.new(bar_index + 11, take_profit_1,
                               "TP1: " + str.tostring(take_profit_1, format.mintick) + " (1:" + str.tostring(tp1_rr, "#.#") + " R:R)" + tp1_status,
                               style=label.style_label_left, color=tp1_color, textcolor=color.white, size=size.tiny)

    // Take Profit 2 Line (dotted)
    if use_multiple_tps and not na(take_profit_2)
        color tp2_color = tp2_hit ? color.new(color_tp, 70) : color_tp
        tp2_line := line.new(entry_bar, take_profit_2, bar_index + 10, take_profit_2,
                             color=tp2_color, width=line_width_sl_tp, style=line.style_dotted)
        float tp2_rr = not na(risk_amount) and risk_amount != 0 ? math.abs(take_profit_2 - entry_price) / risk_amount : 0
        string tp2_status = tp2_hit ? " [HIT]" : ""
        tp2_label := label.new(bar_index + 11, take_profit_2,
                               "TP2: " + str.tostring(take_profit_2, format.mintick) + " (1:" + str.tostring(tp2_rr, "#.#") + " R:R)" + tp2_status,
                               style=label.style_label_left, color=tp2_color, textcolor=color.white, size=size.tiny)

    // Take Profit 3 Line (dotted)
    if use_multiple_tps and not na(take_profit_3)
        color tp3_color = tp3_hit ? color.new(color_tp, 70) : color_tp
        tp3_line := line.new(entry_bar, take_profit_3, bar_index + 10, take_profit_3,
                             color=tp3_color, width=line_width_sl_tp, style=line.style_dotted)
        float tp3_rr = not na(risk_amount) and risk_amount != 0 ? math.abs(take_profit_3 - entry_price) / risk_amount : 0
        string tp3_status = tp3_hit ? " [HIT]" : ""
        tp3_label := label.new(bar_index + 11, take_profit_3,
                               "TP3: " + str.tostring(take_profit_3, format.mintick) + " (1:" + str.tostring(tp3_rr, "#.#") + " R:R)" + tp3_status,
                               style=label.style_label_left, color=tp3_color, textcolor=color.white, size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════════
// CANDLE COLORING
// ═══════════════════════════════════════════════════════════════════════════════

candle_color = color(na)

if show_candle_colors
    if is_aggressive_buy
        candle_color := color_aggressive_buy
    else if is_aggressive_sell
        candle_color := color_aggressive_sell
    else if is_strong_absorption
        candle_color := color_absorption
    else if show_exhaustion_signal
        candle_color := color_exhaustion

barcolor(candle_color, title="Tape Reading Candle Color")

// ═══════════════════════════════════════════════════════════════════════════════
// BACKGROUND HIGHLIGHTS
// ═══════════════════════════════════════════════════════════════════════════════

bgcolor(is_strong_absorption and show_absorption ? color.new(color.blue, 95) : na, title="Absorption Zone")
bgcolor(show_exhaustion_signal and show_exhaustion ? color.new(color.orange, 95) : na, title="Exhaustion Warning")

// ═══════════════════════════════════════════════════════════════════════════════
// VOLUME DELTA HISTOGRAM
// ═══════════════════════════════════════════════════════════════════════════════

// Normalize delta for histogram display
delta_normalized = volume_delta / ta.highest(math.abs(volume_delta), 50) * 100
histogram_color = volume_delta > 0 ? color_delta_buy : color_delta_sell

// Plot only if enabled (use na to hide)
plot(show_delta_histogram ? delta_normalized : na, title="Volume Delta", style=plot.style_histogram, color=histogram_color, linewidth=2)
hline(0, "Zero Line", color=color.gray, linestyle=hline.style_dashed)

// ═══════════════════════════════════════════════════════════════════════════════
// LABELS & SIGNALS
// ═══════════════════════════════════════════════════════════════════════════════

if show_labels
    // Aggressive Buy
    if is_aggressive_buy
        label.new(bar_index, low, "BUY",
                  style=label.style_label_up,
                  color=color_aggressive_buy,
                  textcolor=color.white,
                  size=size.small,
                  tooltip="Aggressive Buying Detected\nInitiative Score: " + str.tostring(initiative_score, "#.##") +
                          "\nVolume Ratio: " + str.tostring(volume_ratio, "#.##"))

    // Aggressive Sell
    if is_aggressive_sell
        label.new(bar_index, high, "SELL",
                  style=label.style_label_down,
                  color=color_aggressive_sell,
                  textcolor=color.white,
                  size=size.small,
                  tooltip="Aggressive Selling Detected\nInitiative Score: " + str.tostring(initiative_score, "#.##") +
                          "\nVolume Ratio: " + str.tostring(volume_ratio, "#.##"))

    // Absorption
    if is_strong_absorption
        label.new(bar_index, high * 1.001, "ABS",
                  style=label.style_label_down,
                  color=color_absorption,
                  textcolor=color.white,
                  size=size.tiny,
                  tooltip="Absorption Detected\nHigh Volume, Narrow Range\nAbsorption Ratio: " + str.tostring(absorption_normalized, "#.##") +
                          "\nSmart Money likely positioning")

    // Exhaustion Warning
    if show_exhaustion_signal
        label.new(bar_index, high * 1.002, "EXH",
                  style=label.style_label_down,
                  color=color_exhaustion,
                  textcolor=color.white,
                  size=size.tiny,
                  tooltip="Exhaustion Warning\nExtreme Volume Detected\nVolume Ratio: " + str.tostring(volume_ratio, "#.##") +
                          "\nWatch for reversal")

// ═══════════════════════════════════════════════════════════════════════════════
// PLOTS FOR ALERTS
// ═══════════════════════════════════════════════════════════════════════════════

plotshape(is_aggressive_buy and show_aggressive, title="Aggressive Buy Signal", style=shape.triangleup, location=location.belowbar, color=color_aggressive_buy, size=size.small)
plotshape(is_aggressive_sell and show_aggressive, title="Aggressive Sell Signal", style=shape.triangledown, location=location.abovebar, color=color_aggressive_sell, size=size.small)
plotshape(is_strong_absorption and show_absorption, title="Absorption Signal", style=shape.circle, location=location.abovebar, color=color_absorption, size=size.tiny)
plotshape(show_exhaustion_signal and show_exhaustion, title="Exhaustion Signal", style=shape.xcross, location=location.abovebar, color=color_exhaustion, size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════════

alertcondition(is_aggressive_buy, title="Aggressive Buying", message="Tape Reading: Aggressive BUY detected - Initiative orders pushing price higher with strong volume")
alertcondition(is_aggressive_sell, title="Aggressive Selling", message="Tape Reading: Aggressive SELL detected - Initiative orders pushing price lower with strong volume")
alertcondition(is_strong_absorption, title="Absorption Zone", message="Tape Reading: ABSORPTION detected - Smart Money potentially accumulating/distributing")
alertcondition(show_exhaustion_signal, title="Exhaustion Warning", message="Tape Reading: EXHAUSTION warning - Extreme volume detected, watch for reversal")

// ═══════════════════════════════════════════════════════════════════════════════
// TABLE: REAL-TIME METRICS DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════

show_metrics_table = input.bool(false, "Show Metrics Table", group=group_visual, tooltip="Display real-time tape reading metrics in a table")

if show_metrics_table and barstate.islast
    var table metrics_table = table.new(position.top_right, 2, 7, border_width=1)

    // Header
    table.cell(metrics_table, 0, 0, "Metric", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(metrics_table, 1, 0, "Value", bgcolor=color.gray, text_color=color.white, text_size=size.small)

    // Volume Ratio
    table.cell(metrics_table, 0, 1, "Volume Ratio", text_size=size.small)
    table.cell(metrics_table, 1, 1, str.tostring(volume_ratio, "#.##"),
               bgcolor=volume_ratio > high_volume_threshold ? color.new(color.green, 80) : na, text_size=size.small)

    // Initiative Score
    table.cell(metrics_table, 0, 2, "Initiative Score", text_size=size.small)
    table.cell(metrics_table, 1, 2, str.tostring(initiative_score, "#.##"),
               bgcolor=initiative_score > initiative_threshold ? color.new(color.yellow, 80) : na, text_size=size.small)

    // Absorption Ratio
    table.cell(metrics_table, 0, 3, "Absorption Ratio", text_size=size.small)
    table.cell(metrics_table, 1, 3, str.tostring(absorption_normalized, "#.##"),
               bgcolor=absorption_normalized > absorption_sensitivity ? color.new(color.blue, 80) : na, text_size=size.small)

    // Volume Delta
    table.cell(metrics_table, 0, 4, "Volume Delta", text_size=size.small)
    delta_color = volume_delta > 0 ? color.new(color.green, 80) : color.new(color.red, 80)
    table.cell(metrics_table, 1, 4, str.tostring(volume_delta, "#"), bgcolor=delta_color, text_size=size.small)

    // Price Velocity
    table.cell(metrics_table, 0, 5, "Price Velocity", text_size=size.small)
    table.cell(metrics_table, 1, 5, str.tostring(price_velocity, "#.####"), text_size=size.small)

    // Current Tape State
    tape_state = is_aggressive_buy ? "AGG BUY" : is_aggressive_sell ? "AGG SELL" : is_strong_absorption ? "ABSORPTION" : show_exhaustion_signal ? "EXHAUSTION" : "NEUTRAL"
    state_color = is_aggressive_buy ? color.new(color.green, 70) : is_aggressive_sell ? color.new(color.red, 70) : is_strong_absorption ? color.new(color.blue, 70) : show_exhaustion_signal ? color.new(color.orange, 70) : na
    table.cell(metrics_table, 0, 6, "Tape State", text_size=size.small)
    table.cell(metrics_table, 1, 6, tape_state, bgcolor=state_color, text_size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════
// TABLE: SIGNALS & TRADE MANAGEMENT DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════

if show_signals_table and show_entry_management and barstate.islast
    // Determine table rows needed
    int table_rows = use_multiple_tps ? 10 : 8
    var table signals_table = table.new(position.bottom_right, 2, table_rows, border_width=1)

    // Direction colors
    color header_color = signal_direction == 1 ? color_long_setup : signal_direction == -1 ? color_short_setup : color.gray
    string signal_type = signal_direction == 1 ? "LONG" : signal_direction == -1 ? "SHORT" : "NO SIGNAL"

    // Header
    table.cell(signals_table, 0, 0, "Trade Info", bgcolor=header_color, text_color=color.white, text_size=size.small)
    table.cell(signals_table, 1, 0, "Value", bgcolor=header_color, text_color=color.white, text_size=size.small)

    // Signal Type
    table.cell(signals_table, 0, 1, "Signal", text_size=size.small)
    table.cell(signals_table, 1, 1, signal_type, bgcolor=header_color, text_color=color.white, text_size=size.small)

    // Entry Price
    table.cell(signals_table, 0, 2, "Entry Price", text_size=size.small)
    string entry_str = not na(entry_price) ? str.tostring(entry_price, format.mintick) : "---"
    table.cell(signals_table, 1, 2, entry_str, text_size=size.small)

    // Stop Loss
    table.cell(signals_table, 0, 3, "Stop Loss", text_size=size.small)
    string sl_str = "---"
    color sl_bg = na
    if not na(stop_loss_price) and not na(entry_price)
        float sl_dist = math.abs(entry_price - stop_loss_price) / entry_price * 100
        sl_str := str.tostring(stop_loss_price, format.mintick) + " (" + str.tostring(sl_dist, "#.##") + "%)"
        sl_bg := sl_hit ? color.new(color.red, 50) : na
    table.cell(signals_table, 1, 3, sl_str, bgcolor=sl_bg, text_size=size.small)

    // Take Profit 1
    table.cell(signals_table, 0, 4, "TP1", text_size=size.small)
    string tp1_str = "---"
    color tp1_bg = na
    if not na(take_profit_1) and not na(entry_price) and not na(risk_amount) and risk_amount != 0
        float tp1_rr_val = math.abs(take_profit_1 - entry_price) / risk_amount
        tp1_str := str.tostring(take_profit_1, format.mintick) + " (1:" + str.tostring(tp1_rr_val, "#.#") + ")"
        tp1_bg := tp1_hit ? color.new(color.teal, 50) : na
    table.cell(signals_table, 1, 4, tp1_str, bgcolor=tp1_bg, text_size=size.small)

    // Take Profit 2 (if multiple TPs enabled)
    if use_multiple_tps
        table.cell(signals_table, 0, 5, "TP2", text_size=size.small)
        string tp2_str = "---"
        color tp2_bg = na
        if not na(take_profit_2) and not na(entry_price) and not na(risk_amount) and risk_amount != 0
            float tp2_rr_val = math.abs(take_profit_2 - entry_price) / risk_amount
            tp2_str := str.tostring(take_profit_2, format.mintick) + " (1:" + str.tostring(tp2_rr_val, "#.#") + ")"
            tp2_bg := tp2_hit ? color.new(color.teal, 50) : na
        table.cell(signals_table, 1, 5, tp2_str, bgcolor=tp2_bg, text_size=size.small)

        // Take Profit 3
        table.cell(signals_table, 0, 6, "TP3", text_size=size.small)
        string tp3_str = "---"
        color tp3_bg = na
        if not na(take_profit_3) and not na(entry_price) and not na(risk_amount) and risk_amount != 0
            float tp3_rr_val = math.abs(take_profit_3 - entry_price) / risk_amount
            tp3_str := str.tostring(take_profit_3, format.mintick) + " (1:" + str.tostring(tp3_rr_val, "#.#") + ")"
            tp3_bg := tp3_hit ? color.new(color.teal, 50) : na
        table.cell(signals_table, 1, 6, tp3_str, bgcolor=tp3_bg, text_size=size.small)

    // P&L Calculation
    int pnl_row = use_multiple_tps ? 7 : 5
    table.cell(signals_table, 0, pnl_row, "Current P&L", text_size=size.small)
    string pnl_str = "---"
    color pnl_bg = na
    if signal_direction != 0 and not na(entry_price)
        float pnl_pct = signal_direction == 1 ? (close - entry_price) / entry_price * 100 : (entry_price - close) / entry_price * 100
        float pnl_r = not na(risk_amount) and risk_amount != 0 ? (signal_direction == 1 ? (close - entry_price) : (entry_price - close)) / risk_amount : 0
        pnl_str := str.tostring(pnl_pct, "#.##") + "% (" + str.tostring(pnl_r, "#.##") + "R)"
        pnl_bg := pnl_pct > 0 ? color.new(color.green, 70) : pnl_pct < 0 ? color.new(color.red, 70) : na
    table.cell(signals_table, 1, pnl_row, pnl_str, bgcolor=pnl_bg, text_size=size.small)

    // Trade Status
    int status_row = use_multiple_tps ? 8 : 6
    table.cell(signals_table, 0, status_row, "Status", text_size=size.small)
    string status_str = "---"
    color status_bg = na
    if signal_direction != 0
        if sl_hit
            status_str := "SL HIT"
            status_bg := color.new(color.red, 50)
        else if use_multiple_tps and tp3_hit
            status_str := "ALL TPs HIT"
            status_bg := color.new(color.teal, 50)
        else if use_multiple_tps and tp2_hit
            status_str := "TP2 HIT"
            status_bg := color.new(color.teal, 60)
        else if tp1_hit
            status_str := "TP1 HIT"
            status_bg := color.new(color.teal, 70)
        else
            status_str := "ACTIVE"
            status_bg := color.new(color.blue, 70)
    table.cell(signals_table, 1, status_row, status_str, bgcolor=status_bg, text_size=size.small)

    // Risk Amount
    int risk_row = use_multiple_tps ? 9 : 7
    table.cell(signals_table, 0, risk_row, "Risk (1R)", text_size=size.small)
    string risk_str = not na(risk_amount) ? str.tostring(risk_amount, format.mintick) : "---"
    table.cell(signals_table, 1, risk_row, risk_str, text_size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════
// ALERT CONDITIONS FOR ENTRY SIGNALS
// ═══════════════════════════════════════════════════════════════════════════════

// Entry signal alerts with SL/TP information
alertcondition(is_aggressive_buy and show_entry_management, title="Long Entry Signal",
    message="Tape Reading: LONG Entry Signal - Check chart for SL/TP levels")
alertcondition(is_aggressive_sell and show_entry_management, title="Short Entry Signal",
    message="Tape Reading: SHORT Entry Signal - Check chart for SL/TP levels")

// ═══════════════════════════════════════════════════════════════════════════════
// EXPLANATION & USAGE NOTES (visible in indicator info)
// ═══════════════════════════════════════════════════════════════════════════════

// HOW TO USE THIS INDICATOR:
//
// 1. AGGRESSIVE ORDERS (Green/Red Labels: BUY/SELL)
//    - Initiative orders from Smart Money or strong participants
//    - Look for: Strong candle body + High volume + Close near high/low
//    - Trading: Follow the direction until exhaustion signals appear
//
// 2. ABSORPTION ZONES (Blue Labels: ABS)
//    - Smart Money accumulating (before uptrend) or distributing (before downtrend)
//    - Look for: High volume but narrow price range (price not moving despite volume)
//    - Trading: Prepare for breakout in the direction of the eventual move
//    - Best used in consolidation zones
//
// 3. EXHAUSTION (Orange Labels: EXH)
//    - Climax volume indicating the move is complete
//    - Look for: Extreme volume (3x+ average) followed by reversal
//    - Trading: Consider taking profits or reversing position
//
// 4. VOLUME DELTA HISTOGRAM (Lower Pane)
//    - Positive (green) = Net buying pressure
//    - Negative (red) = Net selling pressure
//    - Divergences with price can signal reversals
//
// 5. CANDLE COLORING
//    - Green candles = Aggressive buying
//    - Red candles = Aggressive selling
//    - Blue candles = Absorption (watch for breakout)
//    - Orange candles = Exhaustion warning
//
// 6. ENTRY MANAGEMENT MODULE (New Feature)
//    - Automatic entry signals on aggressive buy/sell detection
//    - Stop Loss Types:
//      * Percentage: Fixed % from entry (default 2%)
//      * ATR: Dynamic SL based on ATR multiplier (default 1.5x ATR)
//      * Swing Point: Uses recent swing low (long) / swing high (short)
//    - Take Profit Types:
//      * Percentage: Fixed % from entry (default 4%)
//      * Risk:Reward: Based on SL distance (default 1:2 R:R)
//      * Fixed Points: Absolute point distance
//    - Multiple TPs: TP1, TP2, TP3 with customizable multipliers
//    - Visual Features:
//      * Solid lines for entry price
//      * Dashed lines for stop loss
//      * Dotted lines for take profit levels
//      * Labels show exact prices and R:R ratios
//      * Lines extend from entry bar and update in real-time
//    - Signals Table (bottom-right):
//      * Current signal type (Long/Short)
//      * Entry price, SL, and TP levels
//      * Real-time P&L in % and R multiples
//      * Trade status (Active, TP1 Hit, SL Hit, etc.)
//
// VALIDATION PROCESS:
// - Test on 12 different charts (3 low TF, 3 medium TF, 3 high TF, 3 markets)
// - Check if absorption zones lead to breakouts
// - Verify exhaustion signals precede reversals
// - Confirm aggressive signals align with strong directional moves
//
// BEST PRACTICES:
// - Use on liquid markets with reliable volume data
// - Combine with price action and key levels
// - Absorption works best in ranging markets (preparation phase)
// - Aggressive signals work best in trending markets (momentum phase)
// - Avoid choppy/low-volume periods
// - Use Entry Management for trade planning (not fully automated trading)
// - Adjust SL type based on market volatility (ATR for volatile, % for stable)
// - Consider partial profits at TP1/TP2, let remainder run to TP3
//
// LIMITATIONS:
// - TradingView doesn't provide real delta, so we estimate it
// - Works best on timeframes 1m to Daily
// - Requires sufficient volume data (avoid illiquid assets)
// - Not designed for fully automated trading (discretionary tool)
// - Entry Management is for visualization only (not a strategy)
