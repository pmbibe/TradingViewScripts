// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© AlgoAlpha
// Optimized version with enhanced features by Claude
// Version: 2.0
// Changelog:
//   v2.0 - Performance optimization, Volume/MTF confirmation, SL/TP levels, Signal strength, Dashboard, Enhanced alerts

//@version=6
indicator("Change in State of Delivery CISD [AlgoAlpha] V2", "AlgoAlpha - CISD V2", true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 50)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const int MAX_ITERATIONS = 50
const int MAX_ARRAY_SIZE = 100

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ INPUTS - CORE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tolerance = input.float(0.7, "Noise Filter", group = "âš™ï¸ Core Settings", tooltip = "Determines which levels to use as CISD triggers. Higher value = less noise", maxval = 1, minval = 0, step = 0.1)
len = input.int(12, "Swing Period", group = "âš™ï¸ Core Settings", tooltip = "Period to detect swing points. Larger = longer term swings")
expiry_bars = input.int(100, "Expiry Bars", group = "âš™ï¸ Core Settings", tooltip = "Bars after which old liquidity lines stop updating")
liquidity_lookback = input.int(10, "Liquidity Lookback", group = "âš™ï¸ Core Settings", tooltip = "Lookback to check if opposing liquidity was wicked before CISD", minval = 1, maxval = 50)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” INPUTS - FILTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
use_volume = input.bool(true, "Use Volume Confirmation", group = "ğŸ” Filters", tooltip = "CISD valid when volume > SMA Ã— multiplier")
vol_mult = input.float(1.2, "Volume Multiplier", group = "ğŸ” Filters", minval = 0.5, maxval = 5.0, step = 0.1)
vol_len = input.int(20, "Volume SMA Length", group = "ğŸ” Filters", minval = 5, maxval = 200)

use_session = input.bool(false, "Filter by Session", group = "ğŸ” Filters")
session_input = input.session("0930-1600", "Trading Session", group = "ğŸ” Filters")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š INPUTS - MULTI-TIMEFRAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
use_mtf = input.bool(false, "Use MTF Confirmation", group = "ğŸ“Š Multi-Timeframe", tooltip = "Filter signals by higher timeframe trend")
htf = input.timeframe("60", "Higher Timeframe", group = "ğŸ“Š Multi-Timeframe")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’° INPUTS - RISK MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_sl_tp = input.bool(true, "Show SL/TP Levels", group = "ğŸ’° Risk Management")
risk_reward = input.float(2.0, "Risk/Reward Ratio", group = "ğŸ’° Risk Management", minval = 0.5, maxval = 10, step = 0.5)
atr_mult_sl = input.float(1.5, "ATR Multiplier for SL", group = "ğŸ’° Risk Management", minval = 0.5, maxval = 5, step = 0.1)
atr_len = input.int(14, "ATR Length", group = "ğŸ’° Risk Management", minval = 5, maxval = 100)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ INPUTS - DISPLAY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_dashboard = input.bool(true, "Show Dashboard", group = "ğŸ¨ Display")
show_order_blocks = input.bool(true, "Show Order Blocks", group = "ğŸ¨ Display")
hide_expired_levels = input.bool(true, "Hide Expired Levels", group = "ğŸ¨ Display")
hide_mitigated_levels = input.bool(false, "Hide Mitigated Levels", group = "ğŸ¨ Display")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒˆ INPUTS - COLORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
green = input.color(#00ffbb, "Bullish Color", group = "ğŸŒˆ Colors")
red = input.color(#ff1100, "Bearish Color", group = "ğŸŒˆ Colors")
t1 = input.int(90, "Candle Body Transparency", maxval = 100, minval = 0, group = "ğŸŒˆ Colors")
t2 = input.int(40, "Candle Wick/Border Transparency", maxval = 100, minval = 0, group = "ğŸŒˆ Colors")
ob_transp = input.int(85, "Order Block Transparency", maxval = 100, minval = 0, group = "ğŸŒˆ Colors")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ˆ CALCULATIONS - SWING DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
pivlow = ta.pivotlow(len, len)
pivhigh = ta.pivothigh(len, len)

var swinghighs = array.new_line()
var swinglows = array.new_line()

// Create swing high/low lines
if not na(pivhigh)
    swinghighs.unshift(line.new(bar_index - len, high[len], bar_index, high[len], color = color.new(chart.fg_color, 50)))
if not na(pivlow)
    swinglows.unshift(line.new(bar_index - len, low[len], bar_index, low[len], color = color.new(chart.fg_color, 50)))

// Track last wicked levels
var float last_wicked_high_level = na
var float last_wicked_low_level = na

wicked_high = false
wicked_low = false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ OPTIMIZED - Process swing highs with limited iterations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if swinghighs.size() > 0
    max_iterations = math.min(swinghighs.size(), MAX_ITERATIONS)
    for i = swinghighs.size() - 1 to math.max(0, swinghighs.size() - max_iterations)
        if i < swinghighs.size() and i >= 0
            l = swinghighs.get(i)
            if bar_index - line.get_x1(l) < expiry_bars
                lvl = line.get_y1(l)
                line.set_x2(l, bar_index)
                if high >= lvl and barstate.isconfirmed
                    if hide_mitigated_levels
                        line.delete(l)
                    swinghighs.remove(i)
                    wicked_high := true
                    last_wicked_high_level := lvl
            else
                if hide_expired_levels
                    line.delete(l)
                    swinghighs.remove(i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ OPTIMIZED - Process swing lows with limited iterations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if swinglows.size() > 0
    max_iterations = math.min(swinglows.size(), MAX_ITERATIONS)
    for i = swinglows.size() - 1 to math.max(0, swinglows.size() - max_iterations)
        if i < swinglows.size() and i >= 0
            l = swinglows.get(i)
            if bar_index - line.get_x1(l) < expiry_bars
                lvl = line.get_y1(l)
                line.set_x2(l, bar_index)
                if low <= lvl and barstate.isconfirmed
                    if hide_mitigated_levels
                        line.delete(l)
                    swinglows.remove(i)
                    wicked_low := true
                    last_wicked_low_level := lvl
            else
                if hide_expired_levels
                    line.delete(l)
                    swinglows.remove(i)

// Limit array sizes
while swinghighs.size() > MAX_ARRAY_SIZE
    line.delete(swinghighs.pop())

while swinglows.size() > MAX_ARRAY_SIZE
    line.delete(swinglows.pop())

// Track bars since liquidity sweeps
bars_since_high = ta.barssince(wicked_high)
bars_since_low = ta.barssince(wicked_low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ CISD DETECTION - Potential levels tracking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var bear_potential = array.new_float()
var bull_potential = array.new_float()

// Track bearish reversal candles (green after red)
if close[1] < open[1] and close > open
    bear_potential.unshift(bar_index)
    bear_potential.unshift(open)

// Track bullish reversal candles (red after green)
if close[1] > open[1] and close < open
    bull_potential.unshift(bar_index)
    bull_potential.unshift(open)

cisd = 0
origin_lvl = 0.0
origin_idx = 0.0
var int ob_start_idx = na
var int ob_end_idx = na
var float ob_top = na
var float ob_bottom = na
var int ob_type = 0  // 1 = bearish, 2 = bullish

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”´ OPTIMIZED - Bearish CISD Detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if bear_potential.size() > 0
    // Limit iterations to prevent infinite loops
    max_checks = math.min(bear_potential.size() / 2, MAX_ITERATIONS)
    iteration_count = 0
    is_processing = true

    while is_processing and iteration_count < max_checks
        iteration_count += 1

        if bear_potential.size() < 2
            is_processing := false
            break

        potential_level = bear_potential.first()
        potential_bar = int(bear_potential.get(1))

        if close < potential_level
            // OPTIMIZED: Use ta.highest instead of loop
            lookback = math.min(bar_index - potential_bar, MAX_ITERATIONS)
            highest = ta.highest(close, lookback)

            // Find top of bearish structure
            top = 0.0
            search_idx = bar_index - potential_bar + 1
            search_limit = math.min(MAX_ITERATIONS, bar_index)
            search_count = 0

            while search_idx < bar_index and search_count < search_limit
                if close[search_idx] < open[search_idx] and search_idx >= 0
                    top := open[search_idx]
                    search_idx += 1
                    search_count += 1
                else
                    break

            // Calculate tolerance ratio
            if top > potential_level and (highest - potential_level) / (top - potential_level) > tolerance
                origin_lvl := potential_level
                origin_idx := potential_bar
                ob_start_idx := potential_bar
                ob_end_idx := bar_index
                ob_top := top
                ob_bottom := potential_level
                ob_type := 1
                bear_potential.clear()
                cisd := 1
                is_processing := false
            else
                // Remove this potential and check next
                bear_potential.shift()
                bear_potential.shift()
                if bear_potential.size() == 0
                    is_processing := false
        else
            is_processing := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŸ¢ OPTIMIZED - Bullish CISD Detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if bull_potential.size() > 0
    max_checks = math.min(bull_potential.size() / 2, MAX_ITERATIONS)
    iteration_count = 0
    is_processing = true

    while is_processing and iteration_count < max_checks
        iteration_count += 1

        if bull_potential.size() < 2
            is_processing := false
            break

        potential_level = bull_potential.first()
        potential_bar = int(bull_potential.get(1))

        if close > potential_level
            // OPTIMIZED: Use ta.lowest instead of loop
            lookback = math.min(bar_index - potential_bar, MAX_ITERATIONS)
            lowest = ta.lowest(close, lookback)

            // Find bottom of bullish structure
            bottom = 0.0
            search_idx = bar_index - potential_bar + 1
            search_limit = math.min(MAX_ITERATIONS, bar_index)
            search_count = 0

            while search_idx < bar_index and search_count < search_limit
                if close[search_idx] > open[search_idx] and search_idx >= 0
                    bottom := open[search_idx]
                    search_idx += 1
                    search_count += 1
                else
                    break

            // Calculate tolerance ratio
            if potential_level > bottom and (potential_level - lowest) / (potential_level - bottom) > tolerance
                origin_lvl := potential_level
                origin_idx := potential_bar
                ob_start_idx := potential_bar
                ob_end_idx := bar_index
                ob_top := potential_level
                ob_bottom := bottom
                ob_type := 2
                bull_potential.clear()
                cisd := 2
                is_processing := false
            else
                // Remove this potential and check next
                bull_potential.shift()
                bull_potential.shift()
                if bull_potential.size() == 0
                    is_processing := false
        else
            is_processing := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š VOLUME CONFIRMATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
vol_sma = ta.sma(volume, vol_len)
has_volume_confirmation = not use_volume or (volume > vol_sma * vol_mult)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ• SESSION FILTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
in_session = not use_session or not na(time(timeframe.period, session_input))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ˆ MULTI-TIMEFRAME CONFIRMATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
htf_close = request.security(syminfo.tickerid, htf, close, lookahead = barmerge.lookahead_off)
htf_open = request.security(syminfo.tickerid, htf, open, lookahead = barmerge.lookahead_off)
htf_trend = htf_close > htf_open ? 1 : -1

has_mtf_bull_confirmation = not use_mtf or htf_trend == 1
has_mtf_bear_confirmation = not use_mtf or htf_trend == -1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’° RISK MANAGEMENT - SL/TP CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
atr = ta.atr(atr_len)

var float sl_level = na
var float tp_level = na
var line sl_line = na
var line tp_line = na
var label sl_label = na
var label tp_label = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SIGNAL GENERATION & STRENGTH CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var trend = 0
bearish_sweep = false
bullish_sweep = false
signal_strength = 0

// ğŸ”´ Bearish CISD Signal
if cisd == 1
    trend := -1

    // Check liquidity sweep
    has_sweep = bars_since_high <= liquidity_lookback and close < nz(last_wicked_high_level, high * 2)
    bearish_sweep := has_sweep and has_volume_confirmation and has_mtf_bear_confirmation and in_session

    // Calculate signal strength
    signal_strength := 25  // Base score
    signal_strength += has_sweep ? 35 : 0
    signal_strength += has_volume_confirmation ? 20 : 0
    signal_strength += has_mtf_bear_confirmation ? 20 : 0

    // Draw CISD level line
    line.new(int(origin_idx), origin_lvl, bar_index, origin_lvl, color = red, width = 3)

    // Calculate SL/TP for bearish signal
    if show_sl_tp and bearish_sweep
        sl_level := high + atr * atr_mult_sl
        tp_level := close - (sl_level - close) * risk_reward

        // Draw SL line
        sl_line := line.new(bar_index, sl_level, bar_index + 10, sl_level, color = color.new(color.red, 30), style = line.style_dashed, width = 1)
        sl_label := label.new(bar_index, sl_level, "SL: " + str.tostring(sl_level, format.mintick), style = label.style_label_down, color = color.new(color.red, 30), textcolor = color.white, size = size.tiny)

        // Draw TP line
        tp_line := line.new(bar_index, tp_level, bar_index + 10, tp_level, color = color.new(color.green, 30), style = line.style_dashed, width = 1)
        tp_label := label.new(bar_index, tp_level, "TP: " + str.tostring(tp_level, format.mintick), style = label.style_label_up, color = color.new(color.green, 30), textcolor = color.white, size = size.tiny)

    // Draw Order Block
    if show_order_blocks and not na(ob_start_idx) and not na(ob_top) and not na(ob_bottom)
        box.new(ob_start_idx, ob_top, ob_end_idx, ob_bottom, border_color = color.new(red, 50), bgcolor = color.new(red, ob_transp), text = "OB", text_size = size.tiny, text_color = red)

// ğŸŸ¢ Bullish CISD Signal
if cisd == 2
    trend := 1

    // Check liquidity sweep
    has_sweep = bars_since_low <= liquidity_lookback and close > nz(last_wicked_low_level, low / 2)
    bullish_sweep := has_sweep and has_volume_confirmation and has_mtf_bull_confirmation and in_session

    // Calculate signal strength
    signal_strength := 25  // Base score
    signal_strength += has_sweep ? 35 : 0
    signal_strength += has_volume_confirmation ? 20 : 0
    signal_strength += has_mtf_bull_confirmation ? 20 : 0

    // Draw CISD level line
    line.new(int(origin_idx), origin_lvl, bar_index, origin_lvl, color = green, width = 3)

    // Calculate SL/TP for bullish signal
    if show_sl_tp and bullish_sweep
        sl_level := low - atr * atr_mult_sl
        tp_level := close + (close - sl_level) * risk_reward

        // Draw SL line
        sl_line := line.new(bar_index, sl_level, bar_index + 10, sl_level, color = color.new(color.red, 30), style = line.style_dashed, width = 1)
        sl_label := label.new(bar_index, sl_level, "SL: " + str.tostring(sl_level, format.mintick), style = label.style_label_up, color = color.new(color.red, 30), textcolor = color.white, size = size.tiny)

        // Draw TP line
        tp_line := line.new(bar_index, tp_level, bar_index + 10, tp_level, color = color.new(color.green, 30), style = line.style_dashed, width = 1)
        tp_label := label.new(bar_index, tp_level, "TP: " + str.tostring(tp_level, format.mintick), style = label.style_label_down, color = color.new(color.green, 30), textcolor = color.white, size = size.tiny)

    // Draw Order Block
    if show_order_blocks and not na(ob_start_idx) and not na(ob_top) and not na(ob_bottom)
        box.new(ob_start_idx, ob_top, ob_end_idx, ob_bottom, border_color = color.new(green, 50), bgcolor = color.new(green, ob_transp), text = "OB", text_size = size.tiny, text_color = green)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š INFORMATION DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if show_dashboard
    var table info = table.new(position.top_right, 2, 7, border_width = 1, border_color = color.gray, bgcolor = color.new(chart.bg_color, 10))

    // Header
    table.cell(info, 0, 0, "CISD Dashboard", text_color = chart.fg_color, text_size = size.normal, bgcolor = color.new(chart.fg_color, 90))
    table.merge_cells(info, 0, 0, 1, 0)

    // Current Trend
    trend_text = trend > 0 ? "Bullish" : trend < 0 ? "Bearish" : "Neutral"
    trend_color = trend > 0 ? green : trend < 0 ? red : color.gray
    table.cell(info, 0, 1, "Trend:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 1, trend_text, text_color = trend_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

    // Volume Status
    vol_status = volume > vol_sma * vol_mult ? "High âœ“" : "Low"
    vol_color = volume > vol_sma * vol_mult ? green : color.gray
    table.cell(info, 0, 2, "Volume:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 2, vol_status, text_color = vol_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

    // HTF Trend
    htf_text = use_mtf ? (htf_trend == 1 ? "Up âœ“" : "Down") : "Off"
    htf_color = use_mtf ? (htf_trend == 1 ? green : red) : color.gray
    table.cell(info, 0, 3, "HTF Trend:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 3, htf_text, text_color = htf_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

    // Session Status
    session_text = use_session ? (in_session ? "Active âœ“" : "Inactive") : "Off"
    session_color = use_session ? (in_session ? green : color.gray) : color.gray
    table.cell(info, 0, 4, "Session:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 4, session_text, text_color = session_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

    // ATR
    table.cell(info, 0, 5, "ATR:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 5, str.tostring(atr, format.mintick), text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

    // Risk/Reward
    table.cell(info, 0, 6, "R:R Ratio:", text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))
    table.cell(info, 1, 6, "1:" + str.tostring(risk_reward), text_color = chart.fg_color, text_size = size.small, bgcolor = color.new(chart.bg_color, 10))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ PLOTTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Plot signals - plotshape with fixed text
plotshape(bearish_sweep ? high : na, "Bearish CISD", shape.labeldown, location.abovebar, red, size = size.small, text = "â–¼", textcolor = chart.fg_color)
plotshape(bullish_sweep ? low : na, "Bullish CISD", shape.labelup, location.belowbar, green, size = size.small, text = "â–²", textcolor = chart.fg_color)

// Add labels to show signal strength
if bearish_sweep
    label.new(bar_index, high, str.tostring(signal_strength) + "%", style = label.style_none, yloc = yloc.abovebar, color = color.new(color.white, 100), textcolor = red, size = size.small)

if bullish_sweep
    label.new(bar_index, low, str.tostring(signal_strength) + "%", style = label.style_none, yloc = yloc.belowbar, color = color.new(color.white, 100), textcolor = green, size = size.small)

// Plot swing points
plotchar(not na(pivhigh) ? high[len] : na, "Swing High", "â—", location.absolute, red, size = size.tiny, offset = -len)
plotchar(not na(pivlow) ? low[len] : na, "Swing Low", "â—", location.absolute, green, size = size.tiny, offset = -len)

// Plot colored candles
candle_col = color.from_gradient(t1, 0, 100, trend > 0 ? green : red, chart.bg_color)
candle_col_ = color.from_gradient(t2, 0, 100, trend > 0 ? green : red, chart.bg_color)
plotcandle(open, high, low, close, "Price Candles", candle_col, candle_col_, bordercolor = candle_col_)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ENHANCED ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bearish alert with details
if bearish_sweep
    vol_status = has_volume_confirmation ? "Confirmed" : "Low"
    htf_status = use_mtf ? (htf_trend == -1 ? "Aligned" : "Divergent") : "Off"
    alert_msg = "BEARISH CISD DETECTED | " +
                "Price: " + str.tostring(close, format.mintick) + " | " +
                "SL: " + str.tostring(sl_level, format.mintick) + " | " +
                "TP: " + str.tostring(tp_level, format.mintick) + " | " +
                "Strength: " + str.tostring(signal_strength) + "% | " +
                "Volume: " + vol_status + " | " +
                "HTF: " + htf_status + " | " +
                "R:R 1:" + str.tostring(risk_reward)
    alert(alert_msg, alert.freq_once_per_bar_close)

// Bullish alert with details
if bullish_sweep
    vol_status = has_volume_confirmation ? "Confirmed" : "Low"
    htf_status = use_mtf ? (htf_trend == 1 ? "Aligned" : "Divergent") : "Off"
    alert_msg = "BULLISH CISD DETECTED | " +
                "Price: " + str.tostring(close, format.mintick) + " | " +
                "SL: " + str.tostring(sl_level, format.mintick) + " | " +
                "TP: " + str.tostring(tp_level, format.mintick) + " | " +
                "Strength: " + str.tostring(signal_strength) + "% | " +
                "Volume: " + vol_status + " | " +
                "HTF: " + htf_status + " | " +
                "R:R 1:" + str.tostring(risk_reward)
    alert(alert_msg, alert.freq_once_per_bar_close)

// Basic alerts (for backward compatibility)
alertcondition(wicked_high, "Swing High Mitigation", "Swing High Mitigated")
alertcondition(wicked_low, "Swing Low Mitigation", "Swing Low Mitigated")
alertcondition(cisd == 1, "Bearish Normal CISD", "Bearish Normal CISD Detected")
alertcondition(cisd == 2, "Bullish Normal CISD", "Bullish Normal CISD Detected")
alertcondition(bearish_sweep, "Strong Bearish CISD", "Strong Bearish CISD with " + str.tostring(signal_strength) + "% strength")
alertcondition(bullish_sweep, "Strong Bullish CISD", "Strong Bullish CISD with " + str.tostring(signal_strength) + "% strength")
