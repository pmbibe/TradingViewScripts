// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// Smart Money Phase Detector v1.2 - BOX VISUALIZATION
// Automatically detect and visualize market phases using volume behavior and price structure
// Author: Claude AI Assistant
// Version: 1.2 - Phase Boxes + Improved Dot Display

//@version=5
indicator("Smart Money Phase Detector", "SMPD", overlay=true, max_labels_count=200, max_lines_count=100, max_boxes_count=100)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                         SECTION 1: INPUT PARAMETERS                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Volume Settings ---
string GROUP_VOLUME = "ğŸ“Š Volume Settings"
volume_ma_length = input.int(20, "Volume MA Length", minval=5, maxval=100, group=GROUP_VOLUME)
volume_spike_threshold = input.float(2.0, "Volume Spike Threshold", minval=1.1, maxval=5.0, step=0.1, group=GROUP_VOLUME)
volume_fast_length = input.int(5, "Volume Fast MA", minval=2, maxval=20, group=GROUP_VOLUME)
volume_smoothness_length = input.int(10, "Volume Smoothness Period", minval=5, maxval=30, group=GROUP_VOLUME)

// --- Spread Settings ---
string GROUP_SPREAD = "ğŸ“ Spread Settings"
spread_ma_length = input.int(20, "Spread MA Length", minval=5, maxval=50, group=GROUP_SPREAD)
narrow_threshold = input.float(0.8, "Narrow Spread Threshold", minval=0.3, maxval=1.0, step=0.05, group=GROUP_SPREAD)
wide_threshold = input.float(1.3, "Wide Spread Threshold", minval=1.0, maxval=2.0, step=0.05, group=GROUP_SPREAD)

// --- Phase Detection Settings ---
string GROUP_PHASE = "ğŸ”„ Phase Detection"
accumulation_min_bars = input.int(10, "Min Accumulation Bars", minval=5, maxval=50, group=GROUP_PHASE)
markdown_min_bars = input.int(3, "Min Markdown Bars", minval=2, maxval=10, group=GROUP_PHASE)
confidence_threshold = input.int(70, "Min Confidence %", minval=30, maxval=95, group=GROUP_PHASE)
range_tolerance = input.float(15.0, "Range Tolerance %", minval=5.0, maxval=30.0, step=1.0, group=GROUP_PHASE)

// --- Asset Classification Settings ---
string GROUP_ASSET = "ğŸ·ï¸ Asset Classification"
classification_lookback = input.int(100, "Classification Lookback", minval=50, maxval=200, group=GROUP_ASSET)
smooth_threshold = input.float(0.6, "Smooth Volume Threshold", minval=0.3, maxval=0.9, step=0.05, group=GROUP_ASSET)
spike_count_threshold = input.int(10, "Max Spikes for Smooth", minval=3, maxval=30, group=GROUP_ASSET)

// --- Dot Display Settings (IMPROVED) ---
string GROUP_DOTS = "ğŸ”µ Close Position Dots"
show_dots = input.bool(true, "Show Close Position Dots", group=GROUP_DOTS)
dot_mode = input.string("Strong Signals", "Dot Display Mode", options=["All Bars", "Strong Signals", "Extreme Only", "None"], group=GROUP_DOTS, tooltip="All=every bar, Strong=close>0.65 or <0.35, Extreme=close>0.8 or <0.2")
dot_size = input.string("Tiny", "Dot Size", options=["Tiny", "Small", "Normal"], group=GROUP_DOTS)

// --- Phase Box Settings (NEW) ---
string GROUP_BOX = "ğŸ“¦ Phase Box Display"
show_phase_boxes = input.bool(true, "Show Phase Boxes", group=GROUP_BOX)
box_transparency = input.int(85, "Box Transparency", minval=70, maxval=95, group=GROUP_BOX)
show_phase_labels = input.bool(true, "Show Phase Labels", group=GROUP_BOX)
min_box_bars = input.int(5, "Min Bars for Box", minval=2, maxval=20, group=GROUP_BOX, tooltip="Minimum bars to draw a phase box")

// --- Transition Settings ---
string GROUP_TRANS = "ğŸ”” Transition Signals"
show_transition_arrows = input.bool(true, "Show Transition Arrows", group=GROUP_TRANS)
transition_cooldown = input.int(10, "Min Bars Between Signals", minval=3, maxval=30, group=GROUP_TRANS)
require_phase_confirmation = input.bool(true, "Require Phase for Transition", group=GROUP_TRANS)

// --- Visual Options ---
string GROUP_VISUAL = "ğŸ¨ Other Visual Settings"
show_spread_bands = input.bool(false, "Show Spread Bands", group=GROUP_VISUAL)
show_info_table = input.bool(true, "Show Info Table", group=GROUP_VISUAL)
show_divergence = input.bool(true, "Show Volume Divergence", group=GROUP_VISUAL)
table_position = input.string("Top Right", "Info Table Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=GROUP_VISUAL)

// --- Alert Settings ---
string GROUP_ALERTS = "ğŸ”” Alerts"
enable_phase_alerts = input.bool(true, "Phase Change Alerts", group=GROUP_ALERTS)
enable_transition_alerts = input.bool(true, "Transition Warning Alerts", group=GROUP_ALERTS)
enable_divergence_alerts = input.bool(true, "Divergence Alerts", group=GROUP_ALERTS)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                         SECTION 2: CONSTANTS & COLORS                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Phase Box Colors
color COLOR_MARKDOWN_BOX = color.new(color.red, box_transparency)
color COLOR_ACCUMULATION_BOX = color.new(color.yellow, box_transparency)
color COLOR_MARKUP_BOX = color.new(color.green, box_transparency)
color COLOR_DISTRIBUTION_BOX = color.new(color.orange, box_transparency)

// Phase Border Colors (more visible)
color COLOR_MARKDOWN_BORDER = color.new(color.red, 30)
color COLOR_ACCUMULATION_BORDER = color.new(color.yellow, 30)
color COLOR_MARKUP_BORDER = color.new(color.green, 30)
color COLOR_DISTRIBUTION_BORDER = color.new(color.orange, 30)

// Close Position Dot Colors
color COLOR_STRONG_BUYING = color.new(#00695c, 0)
color COLOR_BUYING = color.new(#4caf50, 0)
color COLOR_NEUTRAL = color.new(#9e9e9e, 0)
color COLOR_SELLING = color.new(#f44336, 0)

// Spread Band Colors
color COLOR_NARROW_SPREAD = color.new(#00bcd4, 85)
color COLOR_WIDE_SPREAD = color.new(#ff5722, 85)

// Phase Constants
int PHASE_UNKNOWN = 0
int PHASE_MARKDOWN = 1
int PHASE_ACCUMULATION = 2
int PHASE_MARKUP = 3
int PHASE_DISTRIBUTION = 4

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                      SECTION 3: VOLUME ANALYSIS MODULE                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float volume_ma = ta.sma(volume, volume_ma_length)
float volume_ma_fast = ta.sma(volume, volume_fast_length)
float volume_ratio = volume_ma > 0 ? volume / volume_ma : 1.0

float volume_stdev = ta.stdev(volume, volume_smoothness_length)
float volume_avg = ta.sma(volume, volume_smoothness_length)
float volume_smoothness = volume_avg > 0 ? math.max(0, 1 - (volume_stdev / volume_avg)) : 0.5

float vqi = volume_ratio * volume_smoothness

float volume_ma_slow = ta.sma(volume, volume_ma_length)
float raw_volume_momentum = volume_ma_slow > 0 ? 100 * (volume_ma_fast - volume_ma_slow) / volume_ma_slow : 0.0
float volume_momentum = math.max(-100, math.min(100, raw_volume_momentum))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                      SECTION 4: PRICE STRUCTURE MODULE                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float spread = high - low
float spread_ma = ta.sma(spread, spread_ma_length)
float spread_ratio = spread_ma > 0 ? spread / spread_ma : 1.0
bool narrow_spread = spread_ratio < narrow_threshold
bool wide_spread = spread_ratio > wide_threshold

float bar_range = high - low
float close_position = bar_range > 0 ? (close - low) / bar_range : 0.5

// Close position classification (ADJUSTED THRESHOLDS)
bool is_strong_buying = close_position > 0.65
bool is_buying = close_position >= 0.5 and close_position <= 0.65
bool is_neutral_close = close_position >= 0.35 and close_position < 0.5
bool is_strong_selling = close_position < 0.35

float upper_band = close + (spread_ma * 1.5)
float lower_band = close - (spread_ma * 1.5)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                       SECTION 5: PHASE DETECTION LOGIC                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_count_consecutive(bool condition) =>
    var int count = 0
    count := condition ? count + 1 : 0
    count

float atr_current = ta.atr(14)
float atr_prev = ta.atr(14)[5]
bool atr_declining = atr_current < atr_prev

float highest_high = ta.highest(high, accumulation_min_bars)
float lowest_low = ta.lowest(low, accumulation_min_bars)
float range_percent = lowest_low > 0 ? ((highest_high - lowest_low) / lowest_low) * 100 : 0

// === MARKDOWN Phase ===
bool markdown_volume = volume > volume_ma * volume_spike_threshold
bool markdown_spread = spread_ratio > wide_threshold
bool markdown_close = close_position < 0.3
bool markdown_downtrend = close < close[1]
bool markdown_lower_lows = low < low[1]
bool markdown_conditions = markdown_volume and markdown_spread and markdown_close and markdown_downtrend and markdown_lower_lows
int markdown_consecutive = f_count_consecutive(markdown_conditions)
bool is_markdown = markdown_consecutive >= markdown_min_bars

// === ACCUMULATION Phase ===
bool accum_low_volume = volume < volume_ma * 0.7
bool accum_narrow_spread = spread_ratio < narrow_threshold
bool accum_tight_range = range_percent < range_tolerance
bool accum_no_breakout = close < ta.highest(high, 20)[1]
bool accum_atr_declining = atr_declining
bool accumulation_conditions = accum_low_volume and accum_narrow_spread and accum_tight_range
int accum_consecutive = f_count_consecutive(accumulation_conditions)
bool is_accumulation = accum_consecutive >= accumulation_min_bars and accum_atr_declining

// === MARKUP Phase ===
bool markup_breakout = close > ta.highest(high, 20)[1]
bool markup_volume_increasing = volume_ma_fast > volume_ma_slow
bool markup_wide_spread = spread_ratio > 1.2
bool markup_strong_close = close_position > 0.7
bool markup_uptrend = close > close[1]
bool markup_higher_highs = high > high[1]
bool markup_conditions = markup_breakout and markup_volume_increasing and markup_strong_close and markup_uptrend
var bool was_accumulation = false
was_accumulation := is_accumulation ? true : (is_markdown ? false : was_accumulation)
bool is_markup = markup_conditions and was_accumulation

// === DISTRIBUTION Phase ===
float highest_50 = ta.highest(high, 50)
bool near_high = highest_50 > 0 ? (high >= highest_50 * 0.95) : false
bool volume_spike = volume > volume_ma * 2
bool no_price_progress = math.abs(high - high[1]) < spread_ma * 0.2
float close_pos_avg_current = ta.sma(close_position, 5)
float close_pos_avg_prev = ta.sma(close_position, 5)[5]
bool close_pos_declining = close_pos_avg_current < close_pos_avg_prev

float upper_wick = high - math.max(open, close)
float wick_ratio = bar_range > 0 ? upper_wick / bar_range : 0
int upper_wick_count = 0
for i = 0 to 4
    if bar_range[i] > 0
        float uw = high[i] - math.max(open[i], close[i])
        if uw / bar_range[i] > 0.3
            upper_wick_count += 1
bool multiple_upper_wicks = upper_wick_count >= 3

float vol_variance = volume_avg > 0 ? volume_stdev / volume_avg : 0
bool high_vol_variance = vol_variance > 0.5
bool distribution_conditions = near_high and (volume_spike or high_vol_variance) and (close_pos_declining or multiple_upper_wicks)
bool is_distribution = distribution_conditions

// === Determine Current Phase ===
var int current_phase = PHASE_UNKNOWN
var int bars_in_phase = 0
var int prev_phase = PHASE_UNKNOWN

int detected_phase = PHASE_UNKNOWN
if is_markdown
    detected_phase := PHASE_MARKDOWN
else if is_distribution
    detected_phase := PHASE_DISTRIBUTION
else if is_markup
    detected_phase := PHASE_MARKUP
else if is_accumulation
    detected_phase := PHASE_ACCUMULATION

if detected_phase != PHASE_UNKNOWN
    if detected_phase != current_phase
        prev_phase := current_phase
        current_phase := detected_phase
        bars_in_phase := 1
    else
        bars_in_phase += 1
else
    bars_in_phase += 1

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                       SECTION 6: ASSET TYPE CLASSIFIER                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float avg_smoothness = ta.sma(volume_smoothness, classification_lookback)
int spike_count = 0
for i = 0 to math.min(classification_lookback - 1, bar_index)
    if volume[i] > volume_ma[i] * 2.5
        spike_count += 1

bool is_smooth_volume = avg_smoothness > smooth_threshold and spike_count < spike_count_threshold
string asset_type = is_smooth_volume ? "Smooth Volume" : "Spikey Volume"
float volume_character_score = math.max(0, math.min(100, avg_smoothness * 100))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                       SECTION 7: PHASE CONFIDENCE SCORE                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_calculate_confidence(int phase) =>
    float conditions_score = 0.0
    int total_conditions = 5
    int met_conditions = 0

    if phase == PHASE_MARKDOWN
        met_conditions := (markdown_volume ? 1 : 0) + (markdown_spread ? 1 : 0) + (markdown_close ? 1 : 0) + (markdown_downtrend ? 1 : 0) + (markdown_lower_lows ? 1 : 0)
    else if phase == PHASE_ACCUMULATION
        met_conditions := (accum_low_volume ? 1 : 0) + (accum_narrow_spread ? 1 : 0) + (accum_tight_range ? 1 : 0) + (accum_atr_declining ? 1 : 0) + (accum_no_breakout ? 1 : 0)
    else if phase == PHASE_MARKUP
        met_conditions := (markup_breakout ? 1 : 0) + (markup_volume_increasing ? 1 : 0) + (markup_strong_close ? 1 : 0) + (markup_uptrend ? 1 : 0) + (markup_higher_highs ? 1 : 0)
    else if phase == PHASE_DISTRIBUTION
        met_conditions := (near_high ? 1 : 0) + (volume_spike ? 1 : 0) + (close_pos_declining ? 1 : 0) + (multiple_upper_wicks ? 1 : 0) + (high_vol_variance ? 1 : 0)

    conditions_score := (float(met_conditions) / float(total_conditions)) * 70.0
    float stability_bonus = math.min(bars_in_phase, 10) * 3.0
    float total = conditions_score + stability_bonus
    math.min(100, total)

float phase_confidence = f_calculate_confidence(current_phase)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                  SECTION 8: TRANSITION ALERTS (WITH COOLDOWN)                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int last_markup_signal_bar = 0
var int last_markdown_signal_bar = 0

bool accum_markup_volume = volume > volume_ma * 1.2 and volume < volume_ma * 2.0
bool accum_markup_spread = spread_ratio > 1.0 and spread_ratio < 1.5
bool accum_markup_close = close_position > 0.6
bool accum_markup_testing = high > ta.highest(high, 10)[1] * 0.99
bool accum_markup_momentum = volume_momentum > 10

bool base_transition_to_markup = accum_markup_volume and accum_markup_spread and accum_markup_close and accum_markup_testing and accum_markup_momentum
bool phase_ok_for_markup = require_phase_confirmation ? (current_phase == PHASE_ACCUMULATION or prev_phase == PHASE_ACCUMULATION) : true
bool cooldown_ok_for_markup = (bar_index - last_markup_signal_bar) >= transition_cooldown
bool transition_to_markup = base_transition_to_markup and phase_ok_for_markup and cooldown_ok_for_markup

if transition_to_markup
    last_markup_signal_bar := bar_index

bool dist_markdown_volume = volume > volume_ma * 1.8
bool dist_markdown_close = close_position < 0.4
bool dist_markdown_wick = wick_ratio > 0.35
bool dist_markdown_decline = close < close[1] and close[1] < close[2]
bool dist_markdown_momentum = volume_momentum < -5

bool base_transition_to_markdown = dist_markdown_volume and dist_markdown_close and (dist_markdown_wick or dist_markdown_decline) and dist_markdown_momentum
bool phase_ok_for_markdown = require_phase_confirmation ? (current_phase == PHASE_DISTRIBUTION or near_high) : true
bool cooldown_ok_for_markdown = (bar_index - last_markdown_signal_bar) >= transition_cooldown
bool transition_to_markdown = base_transition_to_markdown and phase_ok_for_markdown and cooldown_ok_for_markdown

if transition_to_markdown
    last_markdown_signal_bar := bar_index

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                       SECTION 9: DIVERGENCE DETECTION                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int pivot_lookback = 5
bool is_pivot_high = high == ta.highest(high, pivot_lookback * 2 + 1)[pivot_lookback]

var float swing_high_1 = na
var float swing_high_1_vol = na
var int swing_high_1_bar = na
var float swing_high_2 = na
var float swing_high_2_vol = na
var int swing_high_2_bar = na

if is_pivot_high[pivot_lookback]
    swing_high_2 := swing_high_1
    swing_high_2_vol := swing_high_1_vol
    swing_high_2_bar := swing_high_1_bar
    swing_high_1 := high[pivot_lookback]
    swing_high_1_vol := volume[pivot_lookback]
    swing_high_1_bar := bar_index - pivot_lookback

bool price_higher_high = not na(swing_high_1) and not na(swing_high_2) and swing_high_1 > swing_high_2
bool volume_lower_high = not na(swing_high_1_vol) and not na(swing_high_2_vol) and swing_high_1_vol < swing_high_2_vol * 0.8
bool sufficient_distance = not na(swing_high_1_bar) and not na(swing_high_2_bar) and (swing_high_1_bar - swing_high_2_bar) > 15

bool volume_price_divergence = price_higher_high and volume_lower_high and sufficient_distance

float vol_change = volume_ma_fast - volume_ma_fast[5]
float close_pos_change = close_pos_avg_current - close_pos_avg_prev
bool close_position_divergence = vol_change > 0 and close_pos_change < -0.1

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     SECTION 10: PHASE DURATION TRACKING                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var array<int> markdown_durations = array.new_int(0)
var array<int> accum_durations = array.new_int(0)
var array<int> markup_durations = array.new_int(0)
var array<int> dist_durations = array.new_int(0)
var int phase_start_bar = bar_index

bool phase_changed = current_phase != current_phase[1] and current_phase[1] != PHASE_UNKNOWN
if phase_changed
    int duration = bar_index - phase_start_bar
    if current_phase[1] == PHASE_MARKDOWN
        array.push(markdown_durations, duration)
        if array.size(markdown_durations) > 10
            array.shift(markdown_durations)
    else if current_phase[1] == PHASE_ACCUMULATION
        array.push(accum_durations, duration)
        if array.size(accum_durations) > 10
            array.shift(accum_durations)
    else if current_phase[1] == PHASE_MARKUP
        array.push(markup_durations, duration)
        if array.size(markup_durations) > 10
            array.shift(markup_durations)
    else if current_phase[1] == PHASE_DISTRIBUTION
        array.push(dist_durations, duration)
        if array.size(dist_durations) > 10
            array.shift(dist_durations)
    phase_start_bar := bar_index

f_avg_duration(array<int> arr) =>
    if array.size(arr) > 0
        array.avg(arr)
    else
        0.0

float avg_markdown_duration = f_avg_duration(markdown_durations)
float avg_accum_duration = f_avg_duration(accum_durations)
float avg_markup_duration = f_avg_duration(markup_durations)
float avg_dist_duration = f_avg_duration(dist_durations)

float current_avg_duration = current_phase == PHASE_MARKDOWN ? avg_markdown_duration :
                             current_phase == PHASE_ACCUMULATION ? avg_accum_duration :
                             current_phase == PHASE_MARKUP ? avg_markup_duration :
                             current_phase == PHASE_DISTRIBUTION ? avg_dist_duration : 0

float estimated_remaining = math.max(0, current_avg_duration - bars_in_phase)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    SECTION 11: PHASE BOX VISUALIZATION                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track phase box start/end
var int box_start_bar = na
var float box_high = na
var float box_low = na
var int box_phase = PHASE_UNKNOWN
var box current_box = na
var label phase_label = na

// Detect phase change to create boxes
bool new_phase_started = current_phase != current_phase[1] and current_phase != PHASE_UNKNOWN

// Update box high/low
if current_phase != PHASE_UNKNOWN
    if new_phase_started
        // Close previous box if it has enough bars
        if not na(box_start_bar) and (bar_index - box_start_bar) >= min_box_bars and show_phase_boxes
            // Get colors for previous phase
            color prev_box_color = box_phase == PHASE_MARKDOWN ? COLOR_MARKDOWN_BOX :
                                   box_phase == PHASE_ACCUMULATION ? COLOR_ACCUMULATION_BOX :
                                   box_phase == PHASE_MARKUP ? COLOR_MARKUP_BOX :
                                   box_phase == PHASE_DISTRIBUTION ? COLOR_DISTRIBUTION_BOX : na

            color prev_border_color = box_phase == PHASE_MARKDOWN ? COLOR_MARKDOWN_BORDER :
                                      box_phase == PHASE_ACCUMULATION ? COLOR_ACCUMULATION_BORDER :
                                      box_phase == PHASE_MARKUP ? COLOR_MARKUP_BORDER :
                                      box_phase == PHASE_DISTRIBUTION ? COLOR_DISTRIBUTION_BORDER : na

            // Create box for completed phase
            current_box := box.new(box_start_bar, box_high, bar_index - 1, box_low,
                                   border_color=prev_border_color,
                                   bgcolor=prev_box_color,
                                   border_width=2,
                                   border_style=line.style_solid)

            // Add label
            if show_phase_labels
                string prev_phase_name = box_phase == PHASE_MARKDOWN ? "MD" :
                                         box_phase == PHASE_ACCUMULATION ? "ACC" :
                                         box_phase == PHASE_MARKUP ? "MU" :
                                         box_phase == PHASE_DISTRIBUTION ? "DIST" : ""

                phase_label := label.new(box_start_bar + math.round((bar_index - 1 - box_start_bar) / 2), box_high,
                                         prev_phase_name,
                                         color=color.new(color.white, 100),
                                         textcolor=prev_border_color,
                                         style=label.style_label_down,
                                         size=size.small)

        // Start new box
        box_start_bar := bar_index
        box_high := high
        box_low := low
        box_phase := current_phase
    else
        // Update box boundaries
        box_high := math.max(box_high, high)
        box_low := math.min(box_low, low)

// Draw current (incomplete) box on last bar
var box live_box = na
var label live_label = na

if barstate.islast and show_phase_boxes and current_phase != PHASE_UNKNOWN and not na(box_start_bar)
    // Delete previous live box
    box.delete(live_box)
    label.delete(live_label)

    // Get colors for current phase
    color curr_box_color = current_phase == PHASE_MARKDOWN ? COLOR_MARKDOWN_BOX :
                           current_phase == PHASE_ACCUMULATION ? COLOR_ACCUMULATION_BOX :
                           current_phase == PHASE_MARKUP ? COLOR_MARKUP_BOX :
                           current_phase == PHASE_DISTRIBUTION ? COLOR_DISTRIBUTION_BOX : na

    color curr_border_color = current_phase == PHASE_MARKDOWN ? COLOR_MARKDOWN_BORDER :
                              current_phase == PHASE_ACCUMULATION ? COLOR_ACCUMULATION_BORDER :
                              current_phase == PHASE_MARKUP ? COLOR_MARKUP_BORDER :
                              current_phase == PHASE_DISTRIBUTION ? COLOR_DISTRIBUTION_BORDER : na

    // Draw live box (dashed border to show it's active)
    live_box := box.new(box_start_bar, box_high, bar_index, box_low,
                        border_color=curr_border_color,
                        bgcolor=curr_box_color,
                        border_width=2,
                        border_style=line.style_dashed)

    // Add label for current phase
    if show_phase_labels
        string curr_phase_name = current_phase == PHASE_MARKDOWN ? "MARKDOWN" :
                                 current_phase == PHASE_ACCUMULATION ? "ACCUMULATION" :
                                 current_phase == PHASE_MARKUP ? "MARKUP" :
                                 current_phase == PHASE_DISTRIBUTION ? "DISTRIBUTION" : ""

        live_label := label.new(box_start_bar + math.round((bar_index - box_start_bar) / 2), box_high,
                                curr_phase_name + " (" + str.tostring(bars_in_phase) + ")",
                                color=color.new(color.white, 100),
                                textcolor=curr_border_color,
                                style=label.style_label_down,
                                size=size.normal)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   SECTION 12: DOT FILTER (IMPROVED)                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Determine if we should show dot based on filter mode
bool is_extreme_close = close_position < 0.2 or close_position > 0.8
bool is_strong_close = close_position < 0.35 or close_position > 0.65

bool show_dot_all = dot_mode == "All Bars"
bool show_dot_strong = dot_mode == "Strong Signals" and is_strong_close
bool show_dot_extreme = dot_mode == "Extreme Only" and is_extreme_close
bool show_dot_none = dot_mode == "None"

bool should_show_dot = show_dots and (show_dot_all or show_dot_strong or show_dot_extreme) and not show_dot_none

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                          SECTION 13: VISUAL OUTPUT                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// === 13A: Spread Bands ===
color spread_band_color = narrow_spread ? COLOR_NARROW_SPREAD : (wide_spread ? COLOR_WIDE_SPREAD : na)
p_upper = plot(show_spread_bands ? upper_band : na, "Upper Spread Band", color=color.new(color.gray, 70), linewidth=1)
p_lower = plot(show_spread_bands ? lower_band : na, "Lower Spread Band", color=color.new(color.gray, 70), linewidth=1)
fill(p_upper, p_lower, color=show_spread_bands ? spread_band_color : na, title="Spread Fill")

// === 13B: Close Position Dots ===
bool use_tiny = dot_size == "Tiny"
bool use_small = dot_size == "Small"
bool use_normal = dot_size == "Normal"

// Strong Buying dots
plotshape(should_show_dot and is_strong_buying and use_tiny, "Strong Buying", shape.circle, location.abovebar, COLOR_STRONG_BUYING, size=size.tiny)
plotshape(should_show_dot and is_strong_buying and use_small, "Strong Buying", shape.circle, location.abovebar, COLOR_STRONG_BUYING, size=size.small)
plotshape(should_show_dot and is_strong_buying and use_normal, "Strong Buying", shape.circle, location.abovebar, COLOR_STRONG_BUYING, size=size.normal)

// Buying dots
plotshape(should_show_dot and is_buying and use_tiny, "Buying", shape.circle, location.abovebar, COLOR_BUYING, size=size.tiny)
plotshape(should_show_dot and is_buying and use_small, "Buying", shape.circle, location.abovebar, COLOR_BUYING, size=size.small)
plotshape(should_show_dot and is_buying and use_normal, "Buying", shape.circle, location.abovebar, COLOR_BUYING, size=size.normal)

// Neutral dots
plotshape(should_show_dot and is_neutral_close and use_tiny, "Neutral", shape.circle, location.abovebar, COLOR_NEUTRAL, size=size.tiny)
plotshape(should_show_dot and is_neutral_close and use_small, "Neutral", shape.circle, location.abovebar, COLOR_NEUTRAL, size=size.small)
plotshape(should_show_dot and is_neutral_close and use_normal, "Neutral", shape.circle, location.abovebar, COLOR_NEUTRAL, size=size.normal)

// Selling dots
plotshape(should_show_dot and is_strong_selling and use_tiny, "Selling", shape.circle, location.belowbar, COLOR_SELLING, size=size.tiny)
plotshape(should_show_dot and is_strong_selling and use_small, "Selling", shape.circle, location.belowbar, COLOR_SELLING, size=size.small)
plotshape(should_show_dot and is_strong_selling and use_normal, "Selling", shape.circle, location.belowbar, COLOR_SELLING, size=size.normal)

// === 13C: Transition Arrows ===
plotshape(show_transition_arrows and transition_to_markup, "Markup Signal", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.normal, text="MARKUP")
plotshape(show_transition_arrows and transition_to_markdown, "Markdown Signal", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.normal, text="MARKDOWN")

// === 13D: Volume Divergence Labels ===
var label div_label = na
if show_divergence and volume_price_divergence and is_pivot_high[pivot_lookback]
    label.delete(div_label)
    div_label := label.new(bar_index - pivot_lookback, high[pivot_lookback], "VOL DIV",
                           color=color.new(color.yellow, 20),
                           textcolor=color.black,
                           style=label.style_label_down,
                           size=size.small)

// === 13E: Divergence Lines ===
var line div_line = na
if show_divergence and volume_price_divergence and not na(swing_high_1_bar) and not na(swing_high_2_bar)
    line.delete(div_line)
    div_line := line.new(swing_high_2_bar, swing_high_2, swing_high_1_bar, swing_high_1,
                         color=color.new(color.yellow, 30),
                         style=line.style_dotted,
                         width=2)

// === 13F: Info Table ===
var table info_table = na
if show_info_table
    table_pos = table_position == "Top Right" ? position.top_right :
                table_position == "Top Left" ? position.top_left :
                table_position == "Bottom Right" ? position.bottom_right : position.bottom_left

    info_table := table.new(table_pos, 2, 8, bgcolor=color.new(color.black, 80), border_width=1, border_color=color.gray)

    string phase_name = current_phase == PHASE_MARKDOWN ? "MARKDOWN" :
                        current_phase == PHASE_ACCUMULATION ? "ACCUMULATION" :
                        current_phase == PHASE_MARKUP ? "MARKUP" :
                        current_phase == PHASE_DISTRIBUTION ? "DISTRIBUTION" : "SCANNING..."

    color phase_text_color = current_phase == PHASE_MARKDOWN ? color.red :
                             current_phase == PHASE_ACCUMULATION ? color.yellow :
                             current_phase == PHASE_MARKUP ? color.green :
                             current_phase == PHASE_DISTRIBUTION ? color.orange : color.gray

    table.cell(info_table, 0, 0, "ğŸ“Š SMART MONEY", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, "PHASE DETECTOR", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)

    table.cell(info_table, 0, 1, "Phase:", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 1, phase_name, text_color=phase_text_color, text_size=size.small)

    table.cell(info_table, 0, 2, "Confidence:", text_color=color.white, text_size=size.small)
    color conf_color = phase_confidence >= 80 ? color.green : (phase_confidence >= 60 ? color.yellow : color.red)
    table.cell(info_table, 1, 2, str.tostring(math.round(phase_confidence)) + "%", text_color=conf_color, text_size=size.small)

    table.cell(info_table, 0, 3, "Volume Type:", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 3, asset_type, text_color=is_smooth_volume ? color.teal : color.purple, text_size=size.small)

    table.cell(info_table, 0, 4, "Bars in Phase:", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 4, str.tostring(bars_in_phase), text_color=color.white, text_size=size.small)

    table.cell(info_table, 0, 5, "Est. Remaining:", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 5, current_avg_duration > 0 ? str.tostring(math.round(estimated_remaining)) : "N/A", text_color=color.gray, text_size=size.small)

    table.cell(info_table, 0, 6, "VQI:", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 6, str.tostring(math.round(vqi, 2)), text_color=color.white, text_size=size.small)

    table.cell(info_table, 0, 7, "Vol Momentum:", text_color=color.white, text_size=size.small)
    color mom_color = volume_momentum > 20 ? color.green : (volume_momentum < -20 ? color.red : color.gray)
    table.cell(info_table, 1, 7, str.tostring(math.round(volume_momentum, 1)), text_color=mom_color, text_size=size.small)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                         SECTION 14: ALERT CONDITIONS                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool phase_to_accumulation = phase_changed and current_phase == PHASE_ACCUMULATION
bool phase_to_markup = phase_changed and current_phase == PHASE_MARKUP
bool phase_to_distribution = phase_changed and current_phase == PHASE_DISTRIBUTION
bool phase_to_markdown = phase_changed and current_phase == PHASE_MARKDOWN
bool distribution_warning = near_high and volume_spike and close_position < 0.5

alertcondition(enable_phase_alerts and phase_to_accumulation, title="Phase: Accumulation", message="SMPD: Market entered ACCUMULATION phase")
alertcondition(enable_phase_alerts and phase_to_markup, title="Phase: Markup", message="SMPD: Market entered MARKUP phase - Bullish breakout!")
alertcondition(enable_phase_alerts and phase_to_distribution, title="Phase: Distribution", message="SMPD: Market entered DISTRIBUTION phase - Potential top")
alertcondition(enable_phase_alerts and phase_to_markdown, title="Phase: Markdown", message="SMPD: Market entered MARKDOWN phase - Bearish!")

alertcondition(enable_transition_alerts and transition_to_markup, title="Signal: Markup", message="SMPD: MARKUP transition signal detected")
alertcondition(enable_transition_alerts and transition_to_markdown, title="Signal: Markdown", message="SMPD: MARKDOWN transition signal detected")

alertcondition(enable_divergence_alerts and volume_price_divergence, title="Volume Divergence", message="SMPD: Volume-Price DIVERGENCE detected")

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                         SECTION 15: DATA WINDOW OUTPUT                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(vqi, "VQI", color=color.new(color.white, 100), display=display.data_window)
plot(volume_momentum, "Volume Momentum", color=color.new(color.blue, 100), display=display.data_window)
plot(volume_character_score, "Volume Character Score", color=color.new(color.purple, 100), display=display.data_window)
plot(phase_confidence, "Phase Confidence", color=color.new(color.green, 100), display=display.data_window)
plot(float(current_phase), "Current Phase (1=MD,2=AC,3=MU,4=DI)", color=color.new(color.white, 100), display=display.data_window)
plot(close_position, "Close Position", color=color.new(color.white, 100), display=display.data_window)
plot(volume_ratio, "Volume Ratio", color=color.new(color.white, 100), display=display.data_window)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                              END OF INDICATOR                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
